# 20230320
## ì˜¤ëŠ˜ ê³µë¶€í•œ ë‚´ìš©
## - ðŸ“‘ : Now In Android Deep Dive
# Day7 (2023.04.05)

designSystemì„ ê³µë¶€í•˜ìž

## DesignSystem

composeë¥¼ ìž˜ ëª°ë¼ì„œ ì´ˆë°˜ì—ëŠ” ëˆˆëŒ€ì¤‘ìœ¼ë¡œë§Œ ë´¤ëŠ”ë° ë³¼ìˆ˜ë¡ ì‚¬ìš©ì´ ì¢‹ì€ê±°ê°™ë‹¤.

ìš°ì„  ë‚´ê°€ ì²˜ìŒ ë³¸ ëŠë‚Œì€ ë·°ì— ëŒ€í•œ ì»´í¬ë„ŒíŠ¸ë¥¼ ë¯¸ë¦¬ ì •ì˜í•´ì„œ ì •ì˜ëœ ì»´í¬ë„ŒíŠ¸ë¥¼ êº¼ë‚´ì“°ëŠ” ë°©ì‹ìœ¼ë¡œ ìƒê°í–ˆë‹¤. ë‚´ ìƒê°ì´ ë§žëŠ”ì§€ ì•Œì•„ë³´ìž.

```kotlin
/**
 * Now in Android icons. Material icons are[ImageVector]s, custom icons are drawable resource IDs.
 */
object NiaIcons {
    val AccountCircle = Icons.Outlined.AccountCircle
val Add = Icons.Rounded.Add
val ArrowBack = Icons.Rounded.ArrowBack
val ArrowDropDown = Icons.Default.ArrowDropDown
val ArrowDropUp = Icons.Default.ArrowDropUp
val Bookmark = R.drawable.ic_bookmark
val BookmarkBorder = R.drawable.ic_bookmark_border
val Bookmarks = R.drawable.ic_bookmarks
val BookmarksBorder = R.drawable.ic_bookmarks_border
val Check = Icons.Rounded.Check
val Close = Icons.Rounded.Close
val ExpandLess = Icons.Rounded.ExpandLess
val Fullscreen = Icons.Rounded.Fullscreen
val Grid3x3 = Icons.Rounded.Grid3x3
val MenuBook = R.drawable.ic_menu_book
val MenuBookBorder = R.drawable.ic_menu_book_border
val MoreVert = Icons.Default.MoreVert
val Person = Icons.Rounded.Person
val PlayArrow = Icons.Rounded.PlayArrow
val Search = Icons.Rounded.Search
val Settings = Icons.Rounded.Settings
val ShortText = Icons.Rounded.ShortText
val Tag = Icons.Rounded.Tag
val Upcoming = R.drawable.ic_upcoming
val UpcomingBorder = R.drawable.ic_upcoming_border
val ViewDay = Icons.Rounded.ViewDay
val VolumeOff = Icons.Rounded.VolumeOff
val VolumeUp = Icons.Rounded.VolumeUp
}

/**
 * A sealed class to make dealing with[ImageVector] and[DrawableRes] icons easier.
 */
sealed class Icon {
    data class ImageVectorIcon(val imageVector: ImageVector) : Icon()
    data class DrawableResourceIcon(@DrawableRes val id: Int) : Icon()
}

```

ì•„ì´ì½˜ ë¶€ë¶„ì´ë‹¤.

ìžì£¼ ì‚¬ìš©ë˜ëŠ” ì•„ì´ì½˜ì„ ë¯¸ë¦¬ ë³€ìˆ˜ë¡œ ì„ ì–¸í•´ì„œ ì‚¬ìš©í•˜ëŠ”ë¶€ë¶„ì¸ê±°ê°™ë‹¤.

ì£¼ì„ì— ì˜í•˜ë©´ *`Material`* ì•„ì´ì½˜ì„ ê¸°ì¤€ìœ¼ë¡œ ë§Œë“¤ì—ˆê³  ì½”ë“œë¥¼ ë´ë„ ì „ë¶€ *`Material`* ì—ì„œ ê°€ì ¸ì˜¨ê±°ê°™ë‹¤. 

ë°‘ì— sealed classëŠ” ë²¡í„°ì™€ ë“œë¡œìš°ì–´ë¸” ë¦¬ì†ŒìŠ¤ë¥¼ ë‚˜ëˆ„ëŠ” ë¶€ë¶„ì¸ê±°ê°™ë‹¤.

ë‘ ì´ë¯¸ì§€ ëª¨ë‘ ì‚¬ìš©í•´ì•¼í•˜ê¸° ë•Œë¬¸ì´ ì´ëŸ° í˜•ì‹ì´ ë˜ëŠ”ê±°ê°™ë‹¤.

## Theme

```kotlin
/**
 * A class to model background color and tonal elevation values for Now in Android.
 */
@Immutable
data class BackgroundTheme(
    val color: Color = Color.Unspecified,
    val tonalElevation: Dp = Dp.Unspecified,
)

/**
 * A composition local for[BackgroundTheme].
 */
valLocalBackgroundTheme=staticCompositionLocalOf{BackgroundTheme()}
```

ë°°ê²½ìƒ‰ê³¼ ìƒ‰ì¡° ê³ ë„ê°’ì„ ì¡°ì •í•˜ëŠ” ëª¨ë¸ì´ë‹¤.

ì—¬ê¸°ì„œ `@Immutable` ì€ val ë³´ë‹¤ ë” ê°•ë ¥í•œ ë¶ˆë³€ì„ ì„ ì–¸í•˜ëŠ” ì–´ë…¸í…Œì´ì…˜ì´ë‹¤.

Themeì˜ ë°°ê²½ì´ë‹ˆ ì•„ë¬´ëž˜ë„ ìˆ˜ì •ì´ ì•ˆë˜ëŠ”ê²Œ ë§žëŠ”ê±°ê°™ë‹¤.

ê·¸ë¦¬ê³  null ëŒ€ì‹  Unspecifiedì„ ë„£ì–´ì„œ nullì„ í—ˆìš©í•˜ì§€ ì•Šì•˜ë‹¤.

staticCompositionLocalOfì€ composeì˜ í•¨ìˆ˜ë¡œ compositionLocalOfì™€ ë‹¬ë¦¬ ì •ì  ì»´í¬ì§€ì…˜ ë¡œì»¬ ì˜¤ë¸Œì˜ ì½ê¸°ëŠ” Composeì—ì„œ ì¶”ì ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê°’ì„ ë³€ê²½í•˜ë©´ ì»´í¬ì§€ì…˜ì—ì„œ í˜„ìž¬ ê°’ì´ ì½í˜€ì§„ ìœ„ì¹˜ë§Œ ìž¬êµ¬ì„±ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ CompositionLocalì´ ì œê³µëœ ì½˜í…ì¸  ëžŒë‹¤ ì „ì²´ê°€ ìž¬êµ¬ì„±ë©ë‹ˆë‹¤.

ê°„ë‹¨í•˜ê²Œ ì¼ë°˜ ì»´í¬ì¦ˆì˜ ë¦¬ì»´í¬ì¦ˆê°€ íš¨ìœ¨ì ìœ¼ë¡œ í•„ìš”í•œë¶€ë¶„ë§Œ ëœë‹¤ë©´ staticCompositionLocalOfì„ ì‚¬ìš©í•˜ë©´ ì œê³µëœ ì»¨í…ì¸  ì „ì²´ê°€ ìž¬êµ¬ì„±ì´ ëœë‹¤.

```kotlin

/**
 * Now in Android colors.
 */
internal valBlue10=Color(0xFF001F28)
internal valBlue20=Color(0xFF003544)
internal valBlue30=Color(0xFF004D61)
internal valBlue40=Color(0xFF006780)
internal valBlue80=Color(0xFF5DD5FC)
internal valBlue90=Color(0xFFB8EAFF)
internal valBlue95=Color(0xFFDDF4FF)
internal valDarkGreen10=Color(0xFF0D1F12)
internal valDarkGreen20=Color(0xFF223526)
internal valDarkGreen30=Color(0xFF394B3C)
internal valDarkGreen40=Color(0xFF4F6352)
internal valDarkGreen80=Color(0xFFB7CCB8)
internal valDarkGreen90=Color(0xFFD3E8D3)
internal valDarkGreenGray10=Color(0xFF1A1C1A)
internal valDarkGreenGray20=Color(0xFF2F312E)
internal valDarkGreenGray90=Color(0xFFE2E3DE)
internal valDarkGreenGray95=Color(0xFFF0F1EC)
internal valDarkGreenGray99=Color(0xFFFBFDF7)
internal valDarkPurpleGray10=Color(0xFF201A1B)
internal valDarkPurpleGray20=Color(0xFF362F30)
internal valDarkPurpleGray90=Color(0xFFECDFE0)
internal valDarkPurpleGray95=Color(0xFFFAEEEF)
internal valDarkPurpleGray99=Color(0xFFFCFCFC)
internal valGreen10=Color(0xFF00210B)
internal valGreen20=Color(0xFF003919)
internal valGreen30=Color(0xFF005227)
internal valGreen40=Color(0xFF006D36)
internal valGreen80=Color(0xFF0EE37C)
internal valGreen90=Color(0xFF5AFF9D)
internal valGreenGray30=Color(0xFF414941)
internal valGreenGray50=Color(0xFF727971)
internal valGreenGray60=Color(0xFF8B938A)
internal valGreenGray80=Color(0xFFC1C9BF)
internal valGreenGray90=Color(0xFFDDE5DB)
internal valOrange10=Color(0xFF380D00)
internal valOrange20=Color(0xFF5B1A00)
internal valOrange30=Color(0xFF812800)
internal valOrange40=Color(0xFFA23F16)
internal valOrange80=Color(0xFFFFB59B)
internal valOrange90=Color(0xFFFFDBCF)
internal valOrange95=Color(0xFFFFEDE8)
internal valPurple10=Color(0xFF36003C)
internal valPurple20=Color(0xFF560A5D)
internal valPurple30=Color(0xFF702776)
internal valPurple40=Color(0xFF8B418F)
internal valPurple80=Color(0xFFFFA9FE)
internal valPurple90=Color(0xFFFFD6FA)
internal valPurple95=Color(0xFFFFEBFA)
internal valPurpleGray30=Color(0xFF4D444C)
internal valPurpleGray50=Color(0xFF7F747C)
internal valPurpleGray60=Color(0xFF998D96)
internal valPurpleGray80=Color(0xFFD0C3CC)
internal valPurpleGray90=Color(0xFFEDDEE8)
internal valRed10=Color(0xFF410002)
internal valRed20=Color(0xFF690005)
internal valRed30=Color(0xFF93000A)
internal valRed40=Color(0xFFBA1A1A)
internal valRed80=Color(0xFFFFB4AB)
internal valRed90=Color(0xFFFFDAD6)
internal valTeal10=Color(0xFF001F26)
internal valTeal20=Color(0xFF02363F)
internal valTeal30=Color(0xFF214D56)
internal valTeal40=Color(0xFF3A656F)
internal valTeal80=Color(0xFFA2CED9)
internal valTeal90=Color(0xFFBEEAF6)
```

ìœ„ì˜ ì•„ì´ì½˜ê³¼ ë˜‘ê°™ì´ niaì—ì„œ ì‚¬ìš©ë  colorë¥¼ ë¯¸ë¦¬ ì§€ì •í•´ë†“ì€ ê³³ì´ë‹¤.

`internal` ì„ ì´ìš©í•´ ëª¨ë“ˆì•ˆì—ì„œë§Œ ì‚¬ìš©ë˜ë„ë¡ í–ˆë‹¤.

ì•„ë§ˆ ë‹¤ë¥¸ colorì™€ ê²¹ì¹˜ì§€ ì•Šë„ë¡ í•˜ëŠ”ê±°ê°™ë‹¤.

```kotlin
/**
 * A class to model gradient color values for Now in Android.
 *
 *@paramtopThe top gradient color to be rendered.
 *@parambottomThe bottom gradient color to be rendered.
 *@paramcontainerThe container gradient color over which the gradient will be rendered.
 */
@Immutable
data class GradientColors(
    val top: Color = Color.Unspecified,
    val bottom: Color = Color.Unspecified,
    val container: Color = Color.Unspecified,
)

/**
 * A composition local for[GradientColors].
 */
val LocalGradientColors=staticCompositionLocalOf{GradientColors()}
```

ê·¸ë¼ë°ì´ì…˜ì„ ê´€ë¦¬í•˜ëŠ” ëª¨ë¸ì´ë‹¤.

top, bottomìœ¼ë¡œ ê·¸ë¼ë°ì´ì…˜í•  ìƒ‰ìƒì„ ì •í•˜ê³  containerë¡œ ê·¸ë¼ë°ì´ì…˜ì´ ê·¸ë ¤ì§ˆ ìƒ‰ìƒì„ ì •í•œë‹¤.

ê·¸ë¦¬ê³  ì•„ëž˜ LocalGradientColorsë„ staticCompositionLocalOfë¡œ ì „ì œ ë¦¬ì»´í¬ì¦ˆ ë˜ë„ë¡ í•œë‹¤.

```kotlin
/**
 * A class to model background color and tonal elevation values for Now in Android.
 */
@Immutable
data class TintTheme(
    val iconTint: Color? = null,
)

/**
 * A composition local for[TintTheme].
 */
val LocalTintTheme = staticCompositionLocalOf{TintTheme()}
```

ìœ„ì™€ ëª¨ë‘ ê°™ì€ ë°©ì‹ìœ¼ë¡œ tint ì»¬ëŸ¬ë¥¼ ì„¤ì •í•´ì¤€ë‹¤.

```kotlin

/**
 * Light default theme color scheme
 */
@VisibleForTesting
valLightDefaultColorScheme=lightColorScheme(
    primary =Purple40,
    onPrimary = Color.White,
    primaryContainer =Purple90,
    onPrimaryContainer =Purple10,
    secondary =Orange40,
    onSecondary = Color.White,
    secondaryContainer =Orange90,
    onSecondaryContainer =Orange10,
    tertiary =Blue40,
    onTertiary = Color.White,
    tertiaryContainer =Blue90,
    onTertiaryContainer =Blue10,
    error =Red40,
    onError = Color.White,
    errorContainer =Red90,
    onErrorContainer =Red10,
    background =DarkPurpleGray99,
    onBackground =DarkPurpleGray10,
    surface =DarkPurpleGray99,
    onSurface =DarkPurpleGray10,
    surfaceVariant =PurpleGray90,
    onSurfaceVariant =PurpleGray30,
    inverseSurface =DarkPurpleGray20,
    inverseOnSurface =DarkPurpleGray95,
    outline =PurpleGray50,
)

/**
 * Dark default theme color scheme
 */
@VisibleForTesting
valDarkDefaultColorScheme=darkColorScheme(
    primary =Purple80,
    onPrimary =Purple20,
    primaryContainer =Purple30,
    onPrimaryContainer =Purple90,
    secondary =Orange80,
    onSecondary =Orange20,
    secondaryContainer =Orange30,
    onSecondaryContainer =Orange90,
    tertiary =Blue80,
    onTertiary =Blue20,
    tertiaryContainer =Blue30,
    onTertiaryContainer =Blue90,
    error =Red80,
    onError =Red20,
    errorContainer =Red30,
    onErrorContainer =Red90,
    background =DarkPurpleGray10,
    onBackground =DarkPurpleGray90,
    surface =DarkPurpleGray10,
    onSurface =DarkPurpleGray90,
    surfaceVariant =PurpleGray30,
    onSurfaceVariant =PurpleGray80,
    inverseSurface =DarkPurpleGray90,
    inverseOnSurface =DarkPurpleGray10,
    outline =PurpleGray60,
)

/**
 * Light Android theme color scheme
 */
@VisibleForTesting
valLightAndroidColorScheme=lightColorScheme(
    primary =Green40,
    onPrimary = Color.White,
    primaryContainer =Green90,
    onPrimaryContainer =Green10,
    secondary =DarkGreen40,
    onSecondary = Color.White,
    secondaryContainer =DarkGreen90,
    onSecondaryContainer =DarkGreen10,
    tertiary =Teal40,
    onTertiary = Color.White,
    tertiaryContainer =Teal90,
    onTertiaryContainer =Teal10,
    error =Red40,
    onError = Color.White,
    errorContainer =Red90,
    onErrorContainer =Red10,
    background =DarkGreenGray99,
    onBackground =DarkGreenGray10,
    surface =DarkGreenGray99,
    onSurface =DarkGreenGray10,
    surfaceVariant =GreenGray90,
    onSurfaceVariant =GreenGray30,
    inverseSurface =DarkGreenGray20,
    inverseOnSurface =DarkGreenGray95,
    outline =GreenGray50,
)

/**
 * Dark Android theme color scheme
 */
@VisibleForTesting
valDarkAndroidColorScheme=darkColorScheme(
    primary =Green80,
    onPrimary =Green20,
    primaryContainer =Green30,
    onPrimaryContainer =Green90,
    secondary =DarkGreen80,
    onSecondary =DarkGreen20,
    secondaryContainer =DarkGreen30,
    onSecondaryContainer =DarkGreen90,
    tertiary =Teal80,
    onTertiary =Teal20,
    tertiaryContainer =Teal30,
    onTertiaryContainer =Teal90,
    error =Red80,
    onError =Red20,
    errorContainer =Red30,
    onErrorContainer =Red90,
    background =DarkGreenGray10,
    onBackground =DarkGreenGray90,
    surface =DarkGreenGray10,
    onSurface =DarkGreenGray90,
    surfaceVariant =GreenGray30,
    onSurfaceVariant =GreenGray80,
    inverseSurface =DarkGreenGray90,
    inverseOnSurface =DarkGreenGray10,
    outline =GreenGray60,
)

/**
 * Light Android gradient colors
 */
valLightAndroidGradientColors= GradientColors(container =DarkGreenGray95)

/**
 * Dark Android gradient colors
 */
valDarkAndroidGradientColors= GradientColors(container = Color.Black)

/**
 * Light Android background theme
 */
valLightAndroidBackgroundTheme= BackgroundTheme(color =DarkGreenGray95)

/**
 * Dark Android background theme
 */
valDarkAndroidBackgroundTheme= BackgroundTheme(color = Color.Black)

/**
 * Now in Android theme.
 *
 *@paramdarkThemeWhether the theme should use a dark color scheme (follows system by default).
 *@paramandroidThemeWhether the theme should use the Android theme color scheme instead of the
 *        default theme.
 *@paramdisableDynamicThemingIf `true`, disables the use of dynamic theming, even when it is
 *        supported. This parameter has no effect if [androidTheme] is `true`.
 */
@Composable
fun NiaTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    androidTheme: Boolean = false,
    disableDynamicTheming: Boolean = true,
    content: @Composable () -> Unit,
) {
    // Color scheme
    val colorScheme = when {
        androidTheme -> if (darkTheme)DarkAndroidColorSchemeelseLightAndroidColorScheme
!disableDynamicTheming &&supportsDynamicTheming() -> {
            val context =LocalContext.current
            if (darkTheme)dynamicDarkColorScheme(context) elsedynamicLightColorScheme(context)
        }

        else -> if (darkTheme)DarkDefaultColorSchemeelseLightDefaultColorScheme
}
    // Gradient colors
    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))
    val defaultGradientColors = GradientColors(
        top = colorScheme.inverseOnSurface,
        bottom = colorScheme.primaryContainer,
        container = colorScheme.surface,
    )
    val gradientColors = when {
        androidTheme -> if (darkTheme)DarkAndroidGradientColorselseLightAndroidGradientColors
!disableDynamicTheming &&supportsDynamicTheming() -> emptyGradientColors
        else -> defaultGradientColors
    }
    // Background theme
    val defaultBackgroundTheme = BackgroundTheme(
        color = colorScheme.surface,
        tonalElevation = 2.dp,
    )
    val backgroundTheme = when {
        androidTheme -> if (darkTheme)DarkAndroidBackgroundThemeelseLightAndroidBackgroundTheme
else -> defaultBackgroundTheme
    }
    val tintTheme = when {
        androidTheme -> TintTheme()
        !disableDynamicTheming &&supportsDynamicTheming() -> TintTheme(colorScheme.primary)
        else -> TintTheme()
    }
    // Composition locals
    CompositionLocalProvider(
LocalGradientColorsprovides gradientColors,
LocalBackgroundThemeprovides backgroundTheme,
LocalTintThemeprovides tintTheme,
    ){
MaterialTheme(
            colorScheme = colorScheme,
            typography =NiaTypography,
            content = content,
        )
}
}

@ChecksSdkIntAtLeast(api = Build.VERSION_CODES.S)
fun supportsDynamicTheming() = Build.VERSION.SDK_INT>= Build.VERSION_CODES.S

```

Material3ë¥¼ ì‚¬ìš©í•´ì„œ ê¸°ë³¸ë‹¤í¬ëª¨ë“œ, ê¸°ë³¸ë¼ì´íŠ¸ëª¨ë“œ, ì•ˆë“œë¡œì´ë“œ ë‹¤í¬ëª¨ë“œ, ì•ˆë“œë¡œì´ë“œ ë¼ì´íŠ¸ëª¨ë“œ ì´ë ‡ê²Œ 4ê°œë¡œ ë‚˜ëˆˆë‹¤. ì•ˆë“œë¡œì´ë“œì™€ ê¸°ë³¸ í…Œë§ˆì˜ ì°¨ì´ëŠ” ì½”ë“œìƒìœ¼ë¡œëŠ” ë³´ë¼ìƒ‰ ìœ„ì£¼ì¸ì§€ ì´ˆë¡ìƒ‰ ìœ„ì£¼ì¸ì§€ë§Œ ì°¨ì´ê°€ ìžˆëŠ”ê±°ê°™ë‹¤.

ê·¸ë¦¬ê³  ê°ê° ê·¸ë¼ë°ì´ì…˜ containerìƒ‰ìƒë“±ë„ ë”°ë¡œ ì„¤ì •í•œë‹¤.

ê·¸ë¦¬ê³  ë¯¸ë¦¬ ì„ ì–¸ëœ themeì„ ìœ ë™ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ NiaThemeìœ¼ë¡œ ìžì„¸ížˆ ì„¤ì •í•œë‹¤.

ìš°ì„  darkThemeì„ booleanìœ¼ë¡œ ë°›ëŠ”ë° `isSystemInDarkTheme` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ë°›ê³  androidThemeë„ booleanìœ¼ë¡œ ë°›ëŠ”ë‹¤. ê·¸ë¦¬ê³  disableDynamicThemingì„ ë°›ëŠ”ë° í•´ë‹¹ ê°’ìœ¼ë¡œ ê° í•¸ë“œí°ì˜ ì»¬ëŸ¬ë¥¼ ë°›ì•„ ê·¸ê±¸ë¡œ ë‹¤ì´ë‚˜ë¯¹í•˜ê²Œ ì»¬ëŸ¬ë¥¼ ë°”ê¿”ì£¼ëŠ” ê¸°ëŠ¥ì„ ëœ»í•˜ëŠ”ê±°ê°™ë‹¤.

`colorScheme` ì„ ì„¤ì •í•˜ëŠ”ë° `androidTheme` ì¸ì§€ë¥¼ ë³´ê³  ê±°ê¸°ì„œ `darkTheme` ì„ í™•ì¸í•´ì„œ 4ê°€ì§€ themeì¤‘ ë§žëŠ”ê±¸ ì„¤ì •í•´ì¤€ë‹¤.

ê·¸ë¦¬ê³  `!disableDynamicTheming && *supportsDynamicTheming*()` ì´ ì¡°ê±´ì„ í™•ì¸í•˜ëŠ”ë° disableDynamicThemingì€ ìƒì„±ìžë¡œ ë°›ê³  `supportsDynamicTheming` ì€ í•˜ë‹¨ì—ì„œ ì„ ì–¸í•œ í•¨ìˆ˜ë¡œ DynamicThemingì„ ì§€ì›í•˜ëŠ” ë²„ì „ì¸ì§€ë¥¼ ì²´í¬í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

ê·¸ëž˜ì„œ ì´ ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ dynamicThemeìœ¼ë¡œ ìƒ‰ìƒì„ ì„¤ì •í•œë‹¤.

ë‹¤ìŒì€ ê·¸ë¼ë°ì´ì…˜ ì»¬ëŸ¬ë¥¼ ì„¤ì •í•œë‹¤.

ìš°ì„  ë¹ˆ ê·¸ë¼ë°ì´ì…˜ ì»¬ëŸ¬ë¥¼ ì„ ì–¸í•˜ëŠ”ë° *`surfaceColorAtElevation`* ìœ¼ë¡œ ê·¸ë¼ë°ì´ì…˜ì˜ elevationì„ ë¯¸ë¦¬ ì„¤ì •í•œë‹¤.

ê·¸ë¦¬ê³  ê¸°ë³¸ìœ¼ë¡œ ìƒ‰ìƒì„ ë„£ì–´ì£¼ê³  ìœ„ì™€ ë˜‘ê°™ì€ ì¡°ê±´ìœ¼ë¡œ ê° ì¡°ê±´ì— ë§žëŠ” ìƒ‰ìƒì„ ë„£ì–´ì¤€ë‹¤.

ë‹¤ìŒì€ backgroundë¥¼ ì„¤ì •í•œë‹¤.

ê¸°ë³¸ surfaceìƒ‰ìƒê³¼ elevationì„ 2ë¡œ ì„¤ì •í•˜ê³  anddroidThemeì¸ì§€ ì•„ë‹Œì§€ë§Œ ì²´í¬í•´ì„œ ë‹¤í¬ëª¨ë“œë¥¼ êµ¬ë¶„í•´ ë§žëŠ” ìƒ‰ìƒì„ ì„¤ì •í•œë‹¤.

tint ë˜í•œ ë§ˆì°¬ê°€ì§€ë‹¤.

ê·¸ë¦¬ê³  ì•„ëž˜ `CompositionLocalProvider` í•¨ìˆ˜ë¡œ ê°ì‹¸ ìœ„ì—ì„œ ì„¤ì •í•œ ìƒ‰ìƒë“¤ì„ ëª¨ë‘ provide í•´ì¤€ë‹¤. `CompositionLocalProvider` ì€ ëª¨ë“  ì»´í¬ì €ë¸”ì— ë³€ê²½ëœ ìƒ‰ìƒì„ ì ìš©í•˜ê¸° ìœ„í•´ provide í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë‹¤.

```kotlin
/**
 * Now in Android typography.
 */
internal valNiaTypography= Typography(
    displayLarge = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 57.sp,
        lineHeight = 64.sp,
        letterSpacing = (-0.25).sp,
    ),
    displayMedium = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 45.sp,
        lineHeight = 52.sp,
        letterSpacing = 0.sp,
    ),
    displaySmall = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 36.sp,
        lineHeight = 44.sp,
        letterSpacing = 0.sp,
    ),
    headlineLarge = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 32.sp,
        lineHeight = 40.sp,
        letterSpacing = 0.sp,
    ),
    headlineMedium = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 28.sp,
        lineHeight = 36.sp,
        letterSpacing = 0.sp,
    ),
    headlineSmall = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 24.sp,
        lineHeight = 32.sp,
        letterSpacing = 0.sp,
    ),
    titleLarge = TextStyle(
        fontWeight = FontWeight.Bold,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp,
    ),
    titleMedium = TextStyle(
        fontWeight = FontWeight.Bold,
        fontSize = 18.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.1.sp,
    ),
    titleSmall = TextStyle(
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp,
    ),
    bodyLarge = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp,
    ),
    bodyMedium = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.25.sp,
    ),
    bodySmall = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.4.sp,
    ),
    labelLarge = TextStyle(
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp,
    ),
    labelMedium = TextStyle(
        fontWeight = FontWeight.Medium,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp,
    ),
    labelSmall = TextStyle(
        fontWeight = FontWeight.Medium,
        fontSize = 10.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.sp,
    ),
)

```

typeì´ë¼ ë­”ê°€ í…Œë§ˆì— ëŒ€í•œ íƒ€ìž…ì¸ê°€ í–ˆëŠ”ë° textì— ê´€í•œ ì„¤ì •ì´ë‹¤.

`Typography` ì— í•´ë‹¹í•˜ëŠ” ê° ë°ì´í„°ë¥¼ ìžì„¸í•˜ê²Œ weight, í¬ê¸°, ë†’ì´, ìžê°„ë“±ì„ ì„¤ì •í•´ì¤€ë‹¤.

ì´ì œê¹Œì§€ê°€ ê¸°ë³¸ì ì¸ ì„ ì–¸ë¶€ë¶„ì´ê³  component ë””ë ‰í† ë¦¬ì—ì„œ ë³¸ê²©ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë·°ë¥¼ ìƒì„±í•œë‹¤.

## Component

```kotlin
/**
 * The main background for the app.
 * Uses[LocalBackgroundTheme] to set the color and tonal elevation of a[Surface].
 *
 *@parammodifierModifier to be applied to the background.
 *@paramcontentThe background content.
 */
@Composable
fun NiaBackground(
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit,
) {
    val color =LocalBackgroundTheme.current.color
    val tonalElevation =LocalBackgroundTheme.current.tonalElevation
    Surface(
        color = if (color == Color.Unspecified) Color.Transparent else color,
        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dpelse tonalElevation,
        modifier = modifier.fillMaxSize(),
    ){
CompositionLocalProvider(LocalAbsoluteTonalElevationprovides 0.dp){
content()
}
    }
}

/**
 * A gradient background for select screens. Uses[LocalBackgroundTheme] to set the gradient colors
 * of a[Box] within a[Surface].
 *
 *@parammodifierModifier to be applied to the background.
 *@paramgradientColorsThe gradient colors to be rendered.
 *@paramcontentThe background content.
 */
@Composable
fun NiaGradientBackground(
    modifier: Modifier = Modifier,
    gradientColors: GradientColors =LocalGradientColors.current,
    content: @Composable () -> Unit,
) {
    val currentTopColor by rememberUpdatedState(gradientColors.top)
    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)
    Surface(
        color = if (gradientColors.container == Color.Unspecified) {
            Color.Transparent
        } else {
            gradientColors.container
        },
        modifier = modifier.fillMaxSize(),
    ){
Box(
            Modifier
                .fillMaxSize()
                .drawWithCache{
// Compute the start and end coordinates such that the gradients are angled 11.06
                    // degrees off the vertical axis
                    val offset = size.height *tan(
                        Math
                            .toRadians(11.06)
                            .toFloat(),
                    )

                    val start =Offset(size.width / 2 + offset / 2, 0f)
                    val end =Offset(size.width / 2 - offset / 2, size.height)

                    // Create the top gradient that fades out after the halfway point vertically
                    val topGradient = Brush.linearGradient(
                        0ftoif (currentTopColor == Color.Unspecified) {
                            Color.Transparent
                        } else {
                            currentTopColor
                        },
                        0.724ftoColor.Transparent,
                        start = start,
                        end = end,
                    )
                    // Create the bottom gradient that fades in before the halfway point vertically
                    val bottomGradient = Brush.linearGradient(
                        0.2552ftoColor.Transparent,
                        1ftoif (currentBottomColor == Color.Unspecified) {
                            Color.Transparent
                        } else {
                            currentBottomColor
                        },
                        start = start,
                        end = end,
                    )

                    onDrawBehind{
// There is overlap here, so order is important
                        drawRect(topGradient)
                        drawRect(bottomGradient)
}
                },
        ){
content()
}
    }
}

/**
 * Multipreview annotation that represents light and dark themes. Add this annotation to a
 * composable to render the both themes.
 */
@Preview(uiMode = Configuration.UI_MODE_NIGHT_NO, name = "Light theme")
@Preview(uiMode = Configuration.UI_MODE_NIGHT_YES, name = "Dark theme")
annotation class ThemePreviews

@ThemePreviews
@Composable
fun BackgroundDefault() {
    NiaTheme(disableDynamicTheming = true){
NiaBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun BackgroundDynamic() {
    NiaTheme(disableDynamicTheming = false){
NiaBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun BackgroundAndroid() {
    NiaTheme(androidTheme = true){
NiaBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun GradientBackgroundDefault() {
    NiaTheme(disableDynamicTheming = true){
NiaGradientBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun GradientBackgroundDynamic() {
    NiaTheme(disableDynamicTheming = false){
NiaGradientBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun GradientBackgroundAndroid() {
    NiaTheme(androidTheme = true){
NiaGradientBackground(Modifier.size(100.dp), content ={})
}
}

```

`NiaBackground` ì„ ë³´ë©´ ì£¼ì„ì— ì ížŒëŒ€ë¡œ ì•± ë°°ê²½ì˜ ë©”ì¸ì´ë‹¤.

ìœ„ì—ì„œ ë³¸ *`LocalBackgroundTheme`* ìœ¼ë¡œ colorì™€ tonalì„ ì„¤ì •í•˜ê²Œ ëœë‹¤.

ì´ì œ ê°ê° colorì™€ tonalì„ *`LocalBackgroundTheme`*ë¡œ ìµœê·¼ê°’ì„ ê°€ì ¸ì™€ì„œ defaultë¡œ ë„£ì—ˆë˜ Unspecifiedë¥¼ ì²´í¬í•´ì„œ ì„¤ì •í•œë‹¤.

ê·¸ë¦¬ê³  ë§Œì•½ ë³€ê²½ì´ ë˜ë©´ `CompositionLocalProvider` ë¡œ ìž¬ì„¤ì •ì„ í•´ì¤€ë‹¤.

`NiaGradientBackground` ì€ ìœ„ì—ì„œ ê·¸ë¼ë°ì´ì…˜ì´ ì¶”ê°€ê°€ ëœ ë°°ê²½ì´ê³  `gradientColors` ì„ *`LocalGradientColors`*ì˜ ìµœì‹ ê°’ì„ ë°›ì•„ì„œ ì˜¨ë‹¤.

ì—¬ê¸°ì„œë„ Unspecifiedë¥¼ ì²´í¬í•˜ê³  `Box` ì»´í¬ì €ë¸” í•¨ìˆ˜ë¡œ ë³¸ê²©ì ìœ¼ë¡œ ê·¸ë¦°ë‹¤.

ê° ê·¸ë¼ë°ì´ì…˜ ì„¤ì •ì€ ì´ë¯¸ ì½”ë”©ëœ ê°’ìœ¼ë¡œ ê·¸ë¼ë°ì´ì…˜ì´ ë“¤ì–´ê°„ ë°°ê²½ì„ *`drawWithCache`* ë¡œ ê·¸ë¦°ë‹¤.

ê·¸ë¦¬ê³  ì•„ëž˜ë¶€ë¶„ì€ previewë¶€ë¶„ìœ¼ë¡œ í™•ì¸ìš©ë„ì¸ê±°ê°™ë‹¤.

```kotlin
/**
 * Now in Android filled button with generic content slot. Wraps Material 3[Button].
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramcontentPaddingThe spacing values to apply internally between the container and the
 * content.
 *@paramcontentThe button content.
 */
@Composable
fun NiaButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: @Composable RowScope.() -> Unit,
) {
    Button(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        colors = ButtonDefaults.buttonColors(
            containerColor = MaterialTheme.colorScheme.onBackground,
        ),
        contentPadding = contentPadding,
        content = content,
    )
}

/**
 * Now in Android filled button with text and icon content slots.
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramtextThe button text label content.
 *@paramleadingIconThe button leading icon content. Pass `null` here for no leading icon.
 */
@Composable
fun NiaButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    text: @Composable () -> Unit,
    leadingIcon: @Composable (() -> Unit)? = null,
) {
    NiaButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        contentPadding = if (leadingIcon != null) {
            ButtonDefaults.ButtonWithIconContentPadding
        } else {
            ButtonDefaults.ContentPadding
        },
    ){
NiaButtonContent(
            text = text,
            leadingIcon = leadingIcon,
        )
}
}

/**
 * Now in Android outlined button with generic content slot. Wraps Material 3[OutlinedButton].
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramcontentPaddingThe spacing values to apply internally between the container and the
 * content.
 *@paramcontentThe button content.
 */
@Composable
fun NiaOutlinedButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: @Composable RowScope.() -> Unit,
) {
    OutlinedButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        colors = ButtonDefaults.outlinedButtonColors(
            contentColor = MaterialTheme.colorScheme.onBackground,
        ),
        border =BorderStroke(
            width = NiaButtonDefaults.OutlinedButtonBorderWidth,
            color = if (enabled) {
                MaterialTheme.colorScheme.outline
            } else {
                MaterialTheme.colorScheme.onSurface.copy(
                    alpha = NiaButtonDefaults.DisabledOutlinedButtonBorderAlpha,
                )
            },
        ),
        contentPadding = contentPadding,
        content = content,
    )
}

/**
 * Now in Android outlined button with text and icon content slots.
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramtextThe button text label content.
 *@paramleadingIconThe button leading icon content. Pass `null` here for no leading icon.
 */
@Composable
fun NiaOutlinedButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    text: @Composable () -> Unit,
    leadingIcon: @Composable (() -> Unit)? = null,
) {
    NiaOutlinedButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        contentPadding = if (leadingIcon != null) {
            ButtonDefaults.ButtonWithIconContentPadding
        } else {
            ButtonDefaults.ContentPadding
        },
    ){
NiaButtonContent(
            text = text,
            leadingIcon = leadingIcon,
        )
}
}

/**
 * Now in Android text button with generic content slot. Wraps Material 3[TextButton].
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramcontentThe button content.
 */
@Composable
fun NiaTextButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    content: @Composable RowScope.() -> Unit,
) {
    TextButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        colors = ButtonDefaults.textButtonColors(
            contentColor = MaterialTheme.colorScheme.onBackground,
        ),
        content = content,
    )
}

/**
 * Now in Android text button with text and icon content slots.
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramtextThe button text label content.
 *@paramleadingIconThe button leading icon content. Pass `null` here for no leading icon.
 */
@Composable
fun NiaTextButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    text: @Composable () -> Unit,
    leadingIcon: @Composable (() -> Unit)? = null,
) {
    NiaTextButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
    ){
NiaButtonContent(
            text = text,
            leadingIcon = leadingIcon,
        )
}
}

/**
 * Internal Now in Android button content layout for arranging the text label and leading icon.
 *
 *@paramtextThe button text label content.
 *@paramleadingIconThe button leading icon content. Default is `null` for no leading icon.Ã
 */
@Composable
private fun NiaButtonContent(
    text: @Composable () -> Unit,
    leadingIcon: @Composable (() -> Unit)? = null,
) {
    if (leadingIcon != null) {
        Box(Modifier.sizeIn(maxHeight = ButtonDefaults.IconSize)){
leadingIcon()
}
}
    Box(
        Modifier
            .padding(
                start = if (leadingIcon != null) {
                    ButtonDefaults.IconSpacing
                } else {
                    0.dp
},
            ),
    ){
text()
}
}

/**
 * Now in Android button default values.
 */
object NiaButtonDefaults {
    //TODO: File bug
// OutlinedButton border color doesn't respect disabled state by default
    const val DisabledOutlinedButtonBorderAlpha = 0.12f

    //TODO: File bug
// OutlinedButton default border width isn't exposed via ButtonDefaults
    val OutlinedButtonBorderWidth = 1.dp
}

```

ë²„íŠ¼ ë¶€ë¶„ì´ë‹¤.

ì—­ì‹œ ë²„íŠ¼ì— ëŒ€í•œ ë‹¤ì–‘í•œ ë·°ê°€ ìžˆê¸° ë•Œë¬¸ì— ì œë²• ì–‘ì´ ìžˆë‹¤.

ì¼ë‹¨ ê¸°ë³¸ `NiaButton` ë¶€í„° ë³´ë©´ íŠ¹ë³„í•œê±´ ì—†ê³  textë¥¼ ë°›ëŠ”ê²Œ ì•„ë‹ˆë¼ contentë¥¼ ë°›ì•„ì„œ rowë¡œ ë„£ì–´ì£¼ëŠ”ê±°ê°™ë‹¤. 

ì•„ë§ˆ ë‹¤ì–‘í•œ ë·°ë¥¼ ë³´ì—¬ì£¼ê¸° ìœ„í•´ textë¥¼ ì§ì ‘ ë„£ì§€ ì•ŠëŠ”ê±°ê°™ë‹¤.

ê·¸ë¦¬ê³  ë‹¤ìŒì€ textì™€ ì•„ì´ì½˜ ë‘˜ë‹¤ ë“¤ì–´ê°€ëŠ” ë²„íŠ¼ì´ê³  ì•„ì´ì½˜ì˜ ê²½ìš° nullì´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì•ˆë„£ì–´ë„ ë˜ëŠ”ê±°ê°™ë‹¤.

ê·¸ëŸ°ë° ì½”ë“œë¥¼ ë³´ë©´ Button ì»´í¬ì €ë¸” í•¨ìˆ˜ë¥¼ ì“°ì§€ì•Šê³  ì•„ëž˜ ì„ ì–¸ëœ `NiaButton`ê³¼ `NiaButtonContent`ë¥¼ ì‚¬ìš©í•œë‹¤. 

ë‘ í•¨ìˆ˜ì— ëŒ€í•œê±´ ì•„ëž˜ì—ì„œ ë³´ìž.

ë‹¤ìŒì€`NiaOutlinedButton`ìœ¼ë¡œ ê²‰ì— lineì´ ìžˆëŠ” ë²„íŠ¼ì´ë‹¤.

ê·¸ëž˜ì„œ materialì˜ `OutlinedButton` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ê·¸ë¦°ë‹¤.

ê·¸ë¦¬ê³  ê·¸ ì•„ëž˜ ê°™ì€ ì´ë¦„ìœ¼ë¡œ ìœ„ì²˜ëŸ¼ ì•„ì´ì½˜ê³¼ í•¨ê»˜ ê·¸ë¦´ìˆ˜ìžˆëŠ” `NiaOutlinedButton` ì´ ìžˆë‹¤.

ì—­ì‹œ ë™ì¼í•˜ê²Œ ë‚´ë¶€ í•¨ìˆ˜ë¡œ ìž¬êµ¬ì„±í•œë‹¤.

`NiaTextButton` ë²„íŠ¼ì´ ë‹¤ìŒ ì„ ì–¸ë˜ì–´ ìžˆëŠ”ë° ìœ„ì—ì™€ ê±°ì˜ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ contentë¥¼ ë°›ëŠ” í•¨ìˆ˜, ê·¸ë¦¬ê³  textì™€ iconì„ ë°›ëŠ” ë‚´ë¶€í•¨ìˆ˜ë¡œ ìž¬êµ¬ì„±ëœ í•¨ìˆ˜ ì´ë ‡ê²Œ 2ê°œê°€ ì¡´ìž¬í•œë‹¤.

ê·¸ë¦¬ê³  `NiaButtonContent` ê°€ ë§ˆì§€ë§‰ì— ìžˆê³  ì•„ì´ì½˜ê³¼ textë¥¼ ê·¸ë¦¬ëŠ” ê¸°ë³¸ ì»´í¬ì €ë¸” í•¨ìˆ˜ë¥¼ ì„ ì–¸í•´ë‘” ê³³ì´ë‹¤.

```kotlin
/**
 * Now in Android filter chip with included leading checked icon as well as text content slot.
 *
 *@paramselectedWhether the chip is currently checked.
 *@paramonSelectedChangeCalled when the user clicks the chip and toggles checked.
 *@parammodifierModifier to be applied to the chip.
 *@paramenabledControls the enabled state of the chip. When `false`, this chip will not be
 * clickable and will appear disabled to accessibility services.
 *@paramlabelThe text label content.
 */
@Composable
@OptIn(ExperimentalMaterial3Api::class)
fun NiaFilterChip(
    selected: Boolean,
    onSelectedChange: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    label: @Composable () -> Unit,
) {
    FilterChip(
        selected = selected,
        onClick ={onSelectedChange(!selected)},
        label ={
ProvideTextStyle(value = MaterialTheme.typography.labelSmall){
label()
}
        },
        modifier = modifier,
        enabled = enabled,
        leadingIcon = if (selected) {
{
Icon(
                    imageVector = NiaIcons.Check,
                    contentDescription = null,
                )
}
} else {
            null
        },
        shape =CircleShape,
        border = FilterChipDefaults.filterChipBorder(
            borderColor = MaterialTheme.colorScheme.onBackground,
            selectedBorderColor = MaterialTheme.colorScheme.onBackground,
            disabledBorderColor = MaterialTheme.colorScheme.onBackground.copy(
                alpha = NiaChipDefaults.DisabledChipContentAlpha,
            ),
            disabledSelectedBorderColor = MaterialTheme.colorScheme.onBackground.copy(
                alpha = NiaChipDefaults.DisabledChipContentAlpha,
            ),
            selectedBorderWidth = NiaChipDefaults.ChipBorderWidth,
        ),
        colors = FilterChipDefaults.filterChipColors(
            labelColor = MaterialTheme.colorScheme.onBackground,
            iconColor = MaterialTheme.colorScheme.onBackground,
            disabledContainerColor = if (selected) {
                MaterialTheme.colorScheme.onBackground.copy(
                    alpha = NiaChipDefaults.DisabledChipContainerAlpha,
                )
            } else {
                Color.Transparent
            },
            disabledLabelColor = MaterialTheme.colorScheme.onBackground.copy(
                alpha = NiaChipDefaults.DisabledChipContentAlpha,
            ),
            disabledLeadingIconColor = MaterialTheme.colorScheme.onBackground.copy(
                alpha = NiaChipDefaults.DisabledChipContentAlpha,
            ),
            selectedContainerColor = MaterialTheme.colorScheme.primaryContainer,
            selectedLabelColor = MaterialTheme.colorScheme.onBackground,
            selectedLeadingIconColor = MaterialTheme.colorScheme.onBackground,
        ),
    )
}

/**
 * Now in Android chip default values.
 */
object NiaChipDefaults {
    //TODO: File bug
// FilterChip default values aren't exposed via FilterChipDefaults
    const val DisabledChipContainerAlpha = 0.12f
    const val DisabledChipContentAlpha = 0.38f
    val ChipBorderWidth = 1.dp
}

```

chipì„ ì„ ì–¸í•œê³³ìœ¼ë¡œ íŠ¹ë³„í•œê±´ ë”±ížˆ ì—†ì´ niaì— ë§žëŠ” chipì„ ì»´í¬ì¦ˆë¡œ ê·¸ë¦°ë‹¤.

í•´ë‹¹ ë¶€ë¶„ì€ ì½”ë“œë¥¼ ì½ì–´ë„ ì¶©ë¶„í• ê±°ê°™ë‹¤.

```kotlin
/**
 * A wrapper around[AsyncImage] which determines the colorFilter based on the theme
 */
@Composable
fun DynamicAsyncImage(
    imageUrl: String,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    placeholder: Painter? = null,
) {
    val iconTint =LocalTintTheme.current.iconTint
    AsyncImage(
        placeholder = placeholder,
        model = imageUrl,
        contentDescription = contentDescription,
        colorFilter = if (iconTint != null) ColorFilter.tint(iconTint) else null,
        modifier = modifier,
    )
}

```

í•´ë‹¹ ë¶€ë¶„ì€ imageviewì¸ë° AsyncImageëŠ” coil ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ í•¨ìˆ˜ë‹¤.

ë¹„ë™ê¸°ë¥¼ ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ë·°ë¡œ ê¸°ë³¸ ì´ë¯¸ì§€ë·°ë¥¼ ì´ê±¸ë¡œ ëŒ€ì²´í•´ì„œ ì‚¬ìš©í•˜ëŠ”ê±°ê°™ë‹¤.

```kotlin
/**
 * Now in Android toggle button with icon and checked icon content slots. Wraps Material 3
 *[IconButton].
 *
 *@paramcheckedWhether the toggle button is currently checked.
 *@paramonCheckedChangeCalled when the user clicks the toggle button and toggles checked.
 *@parammodifierModifier to be applied to the toggle button.
 *@paramenabledControls the enabled state of the toggle button. When `false`, this toggle button
 * will not be clickable and will appear disabled to accessibility services.
 *@paramiconThe icon content to show when unchecked.
 *@paramcheckedIconThe icon content to show when checked.
 */
@Composable
fun NiaIconToggleButton(
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    icon: @Composable () -> Unit,
    checkedIcon: @Composable () -> Unit = icon,
) {
    //TODO: File bug
// Can't use regular IconToggleButton as it doesn't include a shape (appears square)
    FilledIconToggleButton(
        checked = checked,
        onCheckedChange = onCheckedChange,
        modifier = modifier,
        enabled = enabled,
        colors = IconButtonDefaults.iconToggleButtonColors(
            checkedContainerColor = MaterialTheme.colorScheme.primaryContainer,
            checkedContentColor = MaterialTheme.colorScheme.onPrimaryContainer,
            disabledContainerColor = if (checked) {
                MaterialTheme.colorScheme.onBackground.copy(
                    alpha = NiaIconButtonDefaults.DisabledIconButtonContainerAlpha,
                )
            } else {
                Color.Transparent
            },
        ),
    ){
if (checked) checkedIcon() else icon()
}
}

/**
 * Now in Android icon button default values.
 */
object NiaIconButtonDefaults {
    //TODO: File bug
// IconToggleButton disabled container alpha not exposed by IconButtonDefaults
    const val DisabledIconButtonContainerAlpha = 0.12f
}

```

iconToggleButtonì„ niaì— ë§žê²Œ ì„¤ì •í•˜ëŠ” ë¶€ë¶„ì´ë‹¤.

FilledIconToggleButtonì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” shapeë¥¼ í¬í•¨í•˜ì§€ ì•Šì•„ì„œë¼ê³  í•œë‹¤.

```kotlin
@Composable
fun NiaLoadingWheel(
    contentDesc: String,
    modifier: Modifier = Modifier,
) {
    val infiniteTransition = rememberInfiniteTransition()

    // Specifies the float animation for slowly drawing out the lines on entering
    val startValue = if (LocalInspectionMode.current) 0F else 1F
    val floatAnimValues = (0untilNUM_OF_LINES).map{remember{Animatable(startValue)} }
LaunchedEffect(floatAnimValues){
(0untilNUM_OF_LINES).map{index->
launch{
floatAnimValues[index].animateTo(
                    targetValue = 0F,
                    animationSpec =tween(
                        durationMillis = 100,
                        easing =FastOutSlowInEasing,
                        delayMillis = 40 * index,
                    ),
                )
}
        }
    }

// Specifies the rotation animation of the entire Canvas composable
    val rotationAnim by infiniteTransition.animateFloat(
        initialValue = 0F,
        targetValue = 360F,
        animationSpec =infiniteRepeatable(
            animation =tween(durationMillis =ROTATION_TIME, easing =LinearEasing),
        ),
    )

    // Specifies the color animation for the base-to-progress line color change
    val baseLineColor = MaterialTheme.colorScheme.onBackground
    val progressLineColor = MaterialTheme.colorScheme.inversePrimary
    val colorAnimValues = (0untilNUM_OF_LINES).map{index->
infiniteTransition.animateColor(
            initialValue = baseLineColor,
            targetValue = baseLineColor,
            animationSpec =infiniteRepeatable(
                animation =keyframes{
durationMillis =ROTATION_TIME/ 2
                    progressLineColoratROTATION_TIME/NUM_OF_LINES/ 2withLinearEasing
baseLineColoratROTATION_TIME/NUM_OF_LINESwithLinearEasing
},
                repeatMode = RepeatMode.Restart,
                initialStartOffset = StartOffset(ROTATION_TIME/NUM_OF_LINES/ 2 * index),
            ),
        )
}

// Draws out the LoadingWheel Canvas composable and sets the animations
    Canvas(
        modifier = modifier
            .size(48.dp)
            .padding(8.dp)
            .graphicsLayer{rotationZ = rotationAnim}
.semantics{contentDescription= contentDesc}
.testTag("loadingWheel"),
    ){
repeat(NUM_OF_LINES){index->
rotate(degrees = index * 30f){
drawLine(
                    color = colorAnimValues[index].value,
                    // Animates the initially drawn 1 pixel alpha from 0 to 1
                    alpha = if (floatAnimValues[index].value < 1f) 1f else 0f,
                    strokeWidth = 4F,
                    cap = StrokeCap.Round,
                    start =Offset(size.width / 2, size.height / 4),
                    end =Offset(size.width / 2, floatAnimValues[index].value * size.height / 4),
                )
}
        }
    }
}

@Composable
fun NiaOverlayLoadingWheel(
    contentDesc: String,
    modifier: Modifier = Modifier,
) {
    Surface(
        shape =RoundedCornerShape(60.dp),
        shadowElevation = 8.dp,
        color = MaterialTheme.colorScheme.surface.copy(alpha = 0.83f),
        modifier = modifier
            .size(60.dp),
    ){
NiaLoadingWheel(
            contentDesc = contentDesc,
        )
}
}

@ThemePreviews
@Composable
fun NiaLoadingWheelPreview() {
    NiaTheme{
Surface{
NiaLoadingWheel(contentDesc = "LoadingWheel")
}
    }
}

@ThemePreviews
@Composable
fun NiaOverlayLoadingWheelPreview() {
    NiaTheme{
Surface{
NiaOverlayLoadingWheel(contentDesc = "LoadingWheel")
}
    }
}

private const valROTATION_TIME= 12000
private const valNUM_OF_LINES= 12
```

ë¡œë”©íœ ì„ ì„¤ì •í•˜ëŠ” ë¶€ë¶„ì´ë‹¤.

ë¡œë”©íœ ì€ ê¸°ë³¸ì„ ë¶ˆëŸ¬ì„œ ìˆ˜ì •í•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ canvasë¡œ ìƒˆë¡œ ê·¸ë¦°ë‹¤.

`rememberInfiniteTransition` ë¥¼ ì‚¬ìš©í•´ì„œ ì¼œì§„ ë™ì•ˆì€ ë¬´í•œìœ¼ë¡œ ë°˜ë³µë˜ê²Œ í•˜ê³  ê¸°ë³¸ë·°ëŠ” ì°¸ ì‰¬ìš´ë° ì• ë‹ˆë©”ì´ì…˜ì€ ì•„ì§ ì–´ë µë‹¤.

`floatAnimValues`ì€ ê° ì„ ì˜ ì´ˆê¸° ëª¨ì–‘ì„ ì œì–´í•˜ê¸° ìœ„í•´ ì• ë‹ˆë©”ì´íŠ¸ ê°€ëŠ¥í•œ float ëª©ë¡ì„ ì •ì˜í•˜ê³  ì„ ì€ ê°ê° ì•½ê°„ì˜ ì§€ì—°ì„ ë‘ê³  í•˜ë‚˜ì”© ê·¸ë ¤ì§„ë‹¤.

`LaunchedEffect` ë¡œ ê° ì¤„ì— ëŒ€í•œ ì½”ë£¨í‹´ì„ ì‹¤í–‰í•´ì„œ 1ë¶€í„°0ê¹Œì§€ ì§€ì—°ì„ ì¤˜ ì• ë‹ˆë©”ì´ì…˜í™” í•œë‹¤.

`rotationAnim`ì€ 0ë„ì—ì„œ 360ë„ë¡œ íšŒì „í•˜ê²Œ í•œë‹¤.

`colorAnimValues`ì€ ê¸°ë³¸ ìƒ‰ìƒê³¼ ì§„í–‰ë¥  ìƒ‰ìƒ ì‚¬ì´ì— ì „í™˜ë  ì»¬ëŸ¬ ê°’ì´ë‹¤.

ê·¸ë¦¬ê³  ì´ ì• ë‹ˆë©”ì´ì…˜ì„ ê° themeì— ë§žê²Œ ìƒ‰ìƒì„ ì„¤ì •í•œë‹¤.

ì‚¬ì‹¤ ì´ ë’¤ë¡œ Navigation, Tabs, Tagë“± ìžˆì§€ë§Œ ê¸°ë³¸ë·°ì—ì„œ niaì— ë§žê²Œ ê·¸ë¦¬ê³  ìƒ‰ìƒì„ themeì— ë§žê²Œ ë³€ê²½í•´ì£¼ëŠ”ê²Œ ì „ë¶€ì¸ê±°ê°™ë‹¤.

## ëŠë‚€ì 
ì»´í¬ì¦ˆ ê¸°ë³¸ì€ ê·¸ëž˜ë„ í•œëˆˆì— ë³´ì´ëŠ”ë° ì•„ì§ ì• ë‹ˆë©”ì´ì…˜ ë¶€ë¶„ì´ ë¶€ì¡±í•œê±°ê°™ë‹¤.

## ë‚´ì¼ í•  ì¼
niaì˜ uië¶€ë¶„ì„ ë³¼ê±°ê°™ë‹¤.