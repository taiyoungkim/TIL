# 20230320
## 오늘 공부한 내용
## - 📑 : Now In Android Deep Dive
# Day7 (2023.04.05)

designSystem을 공부하자

## DesignSystem

compose를 잘 몰라서 초반에는 눈대중으로만 봤는데 볼수록 사용이 좋은거같다.

우선 내가 처음 본 느낌은 뷰에 대한 컴포넌트를 미리 정의해서 정의된 컴포넌트를 꺼내쓰는 방식으로 생각했다. 내 생각이 맞는지 알아보자.

```kotlin
/**
 * Now in Android icons. Material icons are[ImageVector]s, custom icons are drawable resource IDs.
 */
object NiaIcons {
    val AccountCircle = Icons.Outlined.AccountCircle
val Add = Icons.Rounded.Add
val ArrowBack = Icons.Rounded.ArrowBack
val ArrowDropDown = Icons.Default.ArrowDropDown
val ArrowDropUp = Icons.Default.ArrowDropUp
val Bookmark = R.drawable.ic_bookmark
val BookmarkBorder = R.drawable.ic_bookmark_border
val Bookmarks = R.drawable.ic_bookmarks
val BookmarksBorder = R.drawable.ic_bookmarks_border
val Check = Icons.Rounded.Check
val Close = Icons.Rounded.Close
val ExpandLess = Icons.Rounded.ExpandLess
val Fullscreen = Icons.Rounded.Fullscreen
val Grid3x3 = Icons.Rounded.Grid3x3
val MenuBook = R.drawable.ic_menu_book
val MenuBookBorder = R.drawable.ic_menu_book_border
val MoreVert = Icons.Default.MoreVert
val Person = Icons.Rounded.Person
val PlayArrow = Icons.Rounded.PlayArrow
val Search = Icons.Rounded.Search
val Settings = Icons.Rounded.Settings
val ShortText = Icons.Rounded.ShortText
val Tag = Icons.Rounded.Tag
val Upcoming = R.drawable.ic_upcoming
val UpcomingBorder = R.drawable.ic_upcoming_border
val ViewDay = Icons.Rounded.ViewDay
val VolumeOff = Icons.Rounded.VolumeOff
val VolumeUp = Icons.Rounded.VolumeUp
}

/**
 * A sealed class to make dealing with[ImageVector] and[DrawableRes] icons easier.
 */
sealed class Icon {
    data class ImageVectorIcon(val imageVector: ImageVector) : Icon()
    data class DrawableResourceIcon(@DrawableRes val id: Int) : Icon()
}

```

아이콘 부분이다.

자주 사용되는 아이콘을 미리 변수로 선언해서 사용하는부분인거같다.

주석에 의하면 *`Material`* 아이콘을 기준으로 만들었고 코드를 봐도 전부 *`Material`* 에서 가져온거같다. 

밑에 sealed class는 벡터와 드로우어블 리소스를 나누는 부분인거같다.

두 이미지 모두 사용해야하기 때문이 이런 형식이 되는거같다.

## Theme

```kotlin
/**
 * A class to model background color and tonal elevation values for Now in Android.
 */
@Immutable
data class BackgroundTheme(
    val color: Color = Color.Unspecified,
    val tonalElevation: Dp = Dp.Unspecified,
)

/**
 * A composition local for[BackgroundTheme].
 */
valLocalBackgroundTheme=staticCompositionLocalOf{BackgroundTheme()}
```

배경색과 색조 고도값을 조정하는 모델이다.

여기서 `@Immutable` 은 val 보다 더 강력한 불변을 선언하는 어노테이션이다.

Theme의 배경이니 아무래도 수정이 안되는게 맞는거같다.

그리고 null 대신 Unspecified을 넣어서 null을 허용하지 않았다.

staticCompositionLocalOf은 compose의 함수로 compositionLocalOf와 달리 정적 컴포지션 로컬 오브의 읽기는 Compose에서 추적되지 않습니다. 값을 변경하면 컴포지션에서 현재 값이 읽혀진 위치만 재구성되는 것이 아니라 CompositionLocal이 제공된 콘텐츠 람다 전체가 재구성됩니다.

간단하게 일반 컴포즈의 리컴포즈가 효율적으로 필요한부분만 된다면 staticCompositionLocalOf을 사용하면 제공된 컨텐츠 전체가 재구성이 된다.

```kotlin

/**
 * Now in Android colors.
 */
internal valBlue10=Color(0xFF001F28)
internal valBlue20=Color(0xFF003544)
internal valBlue30=Color(0xFF004D61)
internal valBlue40=Color(0xFF006780)
internal valBlue80=Color(0xFF5DD5FC)
internal valBlue90=Color(0xFFB8EAFF)
internal valBlue95=Color(0xFFDDF4FF)
internal valDarkGreen10=Color(0xFF0D1F12)
internal valDarkGreen20=Color(0xFF223526)
internal valDarkGreen30=Color(0xFF394B3C)
internal valDarkGreen40=Color(0xFF4F6352)
internal valDarkGreen80=Color(0xFFB7CCB8)
internal valDarkGreen90=Color(0xFFD3E8D3)
internal valDarkGreenGray10=Color(0xFF1A1C1A)
internal valDarkGreenGray20=Color(0xFF2F312E)
internal valDarkGreenGray90=Color(0xFFE2E3DE)
internal valDarkGreenGray95=Color(0xFFF0F1EC)
internal valDarkGreenGray99=Color(0xFFFBFDF7)
internal valDarkPurpleGray10=Color(0xFF201A1B)
internal valDarkPurpleGray20=Color(0xFF362F30)
internal valDarkPurpleGray90=Color(0xFFECDFE0)
internal valDarkPurpleGray95=Color(0xFFFAEEEF)
internal valDarkPurpleGray99=Color(0xFFFCFCFC)
internal valGreen10=Color(0xFF00210B)
internal valGreen20=Color(0xFF003919)
internal valGreen30=Color(0xFF005227)
internal valGreen40=Color(0xFF006D36)
internal valGreen80=Color(0xFF0EE37C)
internal valGreen90=Color(0xFF5AFF9D)
internal valGreenGray30=Color(0xFF414941)
internal valGreenGray50=Color(0xFF727971)
internal valGreenGray60=Color(0xFF8B938A)
internal valGreenGray80=Color(0xFFC1C9BF)
internal valGreenGray90=Color(0xFFDDE5DB)
internal valOrange10=Color(0xFF380D00)
internal valOrange20=Color(0xFF5B1A00)
internal valOrange30=Color(0xFF812800)
internal valOrange40=Color(0xFFA23F16)
internal valOrange80=Color(0xFFFFB59B)
internal valOrange90=Color(0xFFFFDBCF)
internal valOrange95=Color(0xFFFFEDE8)
internal valPurple10=Color(0xFF36003C)
internal valPurple20=Color(0xFF560A5D)
internal valPurple30=Color(0xFF702776)
internal valPurple40=Color(0xFF8B418F)
internal valPurple80=Color(0xFFFFA9FE)
internal valPurple90=Color(0xFFFFD6FA)
internal valPurple95=Color(0xFFFFEBFA)
internal valPurpleGray30=Color(0xFF4D444C)
internal valPurpleGray50=Color(0xFF7F747C)
internal valPurpleGray60=Color(0xFF998D96)
internal valPurpleGray80=Color(0xFFD0C3CC)
internal valPurpleGray90=Color(0xFFEDDEE8)
internal valRed10=Color(0xFF410002)
internal valRed20=Color(0xFF690005)
internal valRed30=Color(0xFF93000A)
internal valRed40=Color(0xFFBA1A1A)
internal valRed80=Color(0xFFFFB4AB)
internal valRed90=Color(0xFFFFDAD6)
internal valTeal10=Color(0xFF001F26)
internal valTeal20=Color(0xFF02363F)
internal valTeal30=Color(0xFF214D56)
internal valTeal40=Color(0xFF3A656F)
internal valTeal80=Color(0xFFA2CED9)
internal valTeal90=Color(0xFFBEEAF6)
```

위의 아이콘과 똑같이 nia에서 사용될 color를 미리 지정해놓은 곳이다.

`internal` 을 이용해 모듈안에서만 사용되도록 했다.

아마 다른 color와 겹치지 않도록 하는거같다.

```kotlin
/**
 * A class to model gradient color values for Now in Android.
 *
 *@paramtopThe top gradient color to be rendered.
 *@parambottomThe bottom gradient color to be rendered.
 *@paramcontainerThe container gradient color over which the gradient will be rendered.
 */
@Immutable
data class GradientColors(
    val top: Color = Color.Unspecified,
    val bottom: Color = Color.Unspecified,
    val container: Color = Color.Unspecified,
)

/**
 * A composition local for[GradientColors].
 */
val LocalGradientColors=staticCompositionLocalOf{GradientColors()}
```

그라데이션을 관리하는 모델이다.

top, bottom으로 그라데이션할 색상을 정하고 container로 그라데이션이 그려질 색상을 정한다.

그리고 아래 LocalGradientColors도 staticCompositionLocalOf로 전제 리컴포즈 되도록 한다.

```kotlin
/**
 * A class to model background color and tonal elevation values for Now in Android.
 */
@Immutable
data class TintTheme(
    val iconTint: Color? = null,
)

/**
 * A composition local for[TintTheme].
 */
val LocalTintTheme = staticCompositionLocalOf{TintTheme()}
```

위와 모두 같은 방식으로 tint 컬러를 설정해준다.

```kotlin

/**
 * Light default theme color scheme
 */
@VisibleForTesting
valLightDefaultColorScheme=lightColorScheme(
    primary =Purple40,
    onPrimary = Color.White,
    primaryContainer =Purple90,
    onPrimaryContainer =Purple10,
    secondary =Orange40,
    onSecondary = Color.White,
    secondaryContainer =Orange90,
    onSecondaryContainer =Orange10,
    tertiary =Blue40,
    onTertiary = Color.White,
    tertiaryContainer =Blue90,
    onTertiaryContainer =Blue10,
    error =Red40,
    onError = Color.White,
    errorContainer =Red90,
    onErrorContainer =Red10,
    background =DarkPurpleGray99,
    onBackground =DarkPurpleGray10,
    surface =DarkPurpleGray99,
    onSurface =DarkPurpleGray10,
    surfaceVariant =PurpleGray90,
    onSurfaceVariant =PurpleGray30,
    inverseSurface =DarkPurpleGray20,
    inverseOnSurface =DarkPurpleGray95,
    outline =PurpleGray50,
)

/**
 * Dark default theme color scheme
 */
@VisibleForTesting
valDarkDefaultColorScheme=darkColorScheme(
    primary =Purple80,
    onPrimary =Purple20,
    primaryContainer =Purple30,
    onPrimaryContainer =Purple90,
    secondary =Orange80,
    onSecondary =Orange20,
    secondaryContainer =Orange30,
    onSecondaryContainer =Orange90,
    tertiary =Blue80,
    onTertiary =Blue20,
    tertiaryContainer =Blue30,
    onTertiaryContainer =Blue90,
    error =Red80,
    onError =Red20,
    errorContainer =Red30,
    onErrorContainer =Red90,
    background =DarkPurpleGray10,
    onBackground =DarkPurpleGray90,
    surface =DarkPurpleGray10,
    onSurface =DarkPurpleGray90,
    surfaceVariant =PurpleGray30,
    onSurfaceVariant =PurpleGray80,
    inverseSurface =DarkPurpleGray90,
    inverseOnSurface =DarkPurpleGray10,
    outline =PurpleGray60,
)

/**
 * Light Android theme color scheme
 */
@VisibleForTesting
valLightAndroidColorScheme=lightColorScheme(
    primary =Green40,
    onPrimary = Color.White,
    primaryContainer =Green90,
    onPrimaryContainer =Green10,
    secondary =DarkGreen40,
    onSecondary = Color.White,
    secondaryContainer =DarkGreen90,
    onSecondaryContainer =DarkGreen10,
    tertiary =Teal40,
    onTertiary = Color.White,
    tertiaryContainer =Teal90,
    onTertiaryContainer =Teal10,
    error =Red40,
    onError = Color.White,
    errorContainer =Red90,
    onErrorContainer =Red10,
    background =DarkGreenGray99,
    onBackground =DarkGreenGray10,
    surface =DarkGreenGray99,
    onSurface =DarkGreenGray10,
    surfaceVariant =GreenGray90,
    onSurfaceVariant =GreenGray30,
    inverseSurface =DarkGreenGray20,
    inverseOnSurface =DarkGreenGray95,
    outline =GreenGray50,
)

/**
 * Dark Android theme color scheme
 */
@VisibleForTesting
valDarkAndroidColorScheme=darkColorScheme(
    primary =Green80,
    onPrimary =Green20,
    primaryContainer =Green30,
    onPrimaryContainer =Green90,
    secondary =DarkGreen80,
    onSecondary =DarkGreen20,
    secondaryContainer =DarkGreen30,
    onSecondaryContainer =DarkGreen90,
    tertiary =Teal80,
    onTertiary =Teal20,
    tertiaryContainer =Teal30,
    onTertiaryContainer =Teal90,
    error =Red80,
    onError =Red20,
    errorContainer =Red30,
    onErrorContainer =Red90,
    background =DarkGreenGray10,
    onBackground =DarkGreenGray90,
    surface =DarkGreenGray10,
    onSurface =DarkGreenGray90,
    surfaceVariant =GreenGray30,
    onSurfaceVariant =GreenGray80,
    inverseSurface =DarkGreenGray90,
    inverseOnSurface =DarkGreenGray10,
    outline =GreenGray60,
)

/**
 * Light Android gradient colors
 */
valLightAndroidGradientColors= GradientColors(container =DarkGreenGray95)

/**
 * Dark Android gradient colors
 */
valDarkAndroidGradientColors= GradientColors(container = Color.Black)

/**
 * Light Android background theme
 */
valLightAndroidBackgroundTheme= BackgroundTheme(color =DarkGreenGray95)

/**
 * Dark Android background theme
 */
valDarkAndroidBackgroundTheme= BackgroundTheme(color = Color.Black)

/**
 * Now in Android theme.
 *
 *@paramdarkThemeWhether the theme should use a dark color scheme (follows system by default).
 *@paramandroidThemeWhether the theme should use the Android theme color scheme instead of the
 *        default theme.
 *@paramdisableDynamicThemingIf `true`, disables the use of dynamic theming, even when it is
 *        supported. This parameter has no effect if [androidTheme] is `true`.
 */
@Composable
fun NiaTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    androidTheme: Boolean = false,
    disableDynamicTheming: Boolean = true,
    content: @Composable () -> Unit,
) {
    // Color scheme
    val colorScheme = when {
        androidTheme -> if (darkTheme)DarkAndroidColorSchemeelseLightAndroidColorScheme
!disableDynamicTheming &&supportsDynamicTheming() -> {
            val context =LocalContext.current
            if (darkTheme)dynamicDarkColorScheme(context) elsedynamicLightColorScheme(context)
        }

        else -> if (darkTheme)DarkDefaultColorSchemeelseLightDefaultColorScheme
}
    // Gradient colors
    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))
    val defaultGradientColors = GradientColors(
        top = colorScheme.inverseOnSurface,
        bottom = colorScheme.primaryContainer,
        container = colorScheme.surface,
    )
    val gradientColors = when {
        androidTheme -> if (darkTheme)DarkAndroidGradientColorselseLightAndroidGradientColors
!disableDynamicTheming &&supportsDynamicTheming() -> emptyGradientColors
        else -> defaultGradientColors
    }
    // Background theme
    val defaultBackgroundTheme = BackgroundTheme(
        color = colorScheme.surface,
        tonalElevation = 2.dp,
    )
    val backgroundTheme = when {
        androidTheme -> if (darkTheme)DarkAndroidBackgroundThemeelseLightAndroidBackgroundTheme
else -> defaultBackgroundTheme
    }
    val tintTheme = when {
        androidTheme -> TintTheme()
        !disableDynamicTheming &&supportsDynamicTheming() -> TintTheme(colorScheme.primary)
        else -> TintTheme()
    }
    // Composition locals
    CompositionLocalProvider(
LocalGradientColorsprovides gradientColors,
LocalBackgroundThemeprovides backgroundTheme,
LocalTintThemeprovides tintTheme,
    ){
MaterialTheme(
            colorScheme = colorScheme,
            typography =NiaTypography,
            content = content,
        )
}
}

@ChecksSdkIntAtLeast(api = Build.VERSION_CODES.S)
fun supportsDynamicTheming() = Build.VERSION.SDK_INT>= Build.VERSION_CODES.S

```

Material3를 사용해서 기본다크모드, 기본라이트모드, 안드로이드 다크모드, 안드로이드 라이트모드 이렇게 4개로 나눈다. 안드로이드와 기본 테마의 차이는 코드상으로는 보라색 위주인지 초록색 위주인지만 차이가 있는거같다.

그리고 각각 그라데이션 container색상등도 따로 설정한다.

그리고 미리 선언된 theme을 유동적으로 사용하기 위해 NiaTheme으로 자세히 설정한다.

우선 darkTheme을 boolean으로 받는데 `isSystemInDarkTheme` 함수를 사용해서 받고 androidTheme도 boolean으로 받는다. 그리고 disableDynamicTheming을 받는데 해당 값으로 각 핸드폰의 컬러를 받아 그걸로 다이나믹하게 컬러를 바꿔주는 기능을 뜻하는거같다.

`colorScheme` 을 설정하는데 `androidTheme` 인지를 보고 거기서 `darkTheme` 을 확인해서 4가지 theme중 맞는걸 설정해준다.

그리고 `!disableDynamicTheming && *supportsDynamicTheming*()` 이 조건을 확인하는데 disableDynamicTheming은 생성자로 받고 `supportsDynamicTheming` 은 하단에서 선언한 함수로 DynamicTheming을 지원하는 버전인지를 체크하는 함수이다.

그래서 이 조건을 만족하면 dynamicTheme으로 색상을 설정한다.

다음은 그라데이션 컬러를 설정한다.

우선 빈 그라데이션 컬러를 선언하는데 *`surfaceColorAtElevation`* 으로 그라데이션의 elevation을 미리 설정한다.

그리고 기본으로 색상을 넣어주고 위와 똑같은 조건으로 각 조건에 맞는 색상을 넣어준다.

다음은 background를 설정한다.

기본 surface색상과 elevation을 2로 설정하고 anddroidTheme인지 아닌지만 체크해서 다크모드를 구분해 맞는 색상을 설정한다.

tint 또한 마찬가지다.

그리고 아래 `CompositionLocalProvider` 함수로 감싸 위에서 설정한 색상들을 모두 provide 해준다. `CompositionLocalProvider` 은 모든 컴포저블에 변경된 색상을 적용하기 위해 provide 해주는 함수이다.

```kotlin
/**
 * Now in Android typography.
 */
internal valNiaTypography= Typography(
    displayLarge = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 57.sp,
        lineHeight = 64.sp,
        letterSpacing = (-0.25).sp,
    ),
    displayMedium = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 45.sp,
        lineHeight = 52.sp,
        letterSpacing = 0.sp,
    ),
    displaySmall = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 36.sp,
        lineHeight = 44.sp,
        letterSpacing = 0.sp,
    ),
    headlineLarge = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 32.sp,
        lineHeight = 40.sp,
        letterSpacing = 0.sp,
    ),
    headlineMedium = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 28.sp,
        lineHeight = 36.sp,
        letterSpacing = 0.sp,
    ),
    headlineSmall = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 24.sp,
        lineHeight = 32.sp,
        letterSpacing = 0.sp,
    ),
    titleLarge = TextStyle(
        fontWeight = FontWeight.Bold,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp,
    ),
    titleMedium = TextStyle(
        fontWeight = FontWeight.Bold,
        fontSize = 18.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.1.sp,
    ),
    titleSmall = TextStyle(
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp,
    ),
    bodyLarge = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp,
    ),
    bodyMedium = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.25.sp,
    ),
    bodySmall = TextStyle(
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.4.sp,
    ),
    labelLarge = TextStyle(
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp,
    ),
    labelMedium = TextStyle(
        fontWeight = FontWeight.Medium,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp,
    ),
    labelSmall = TextStyle(
        fontWeight = FontWeight.Medium,
        fontSize = 10.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.sp,
    ),
)

```

type이라 뭔가 테마에 대한 타입인가 했는데 text에 관한 설정이다.

`Typography` 에 해당하는 각 데이터를 자세하게 weight, 크기, 높이, 자간등을 설정해준다.

이제까지가 기본적인 선언부분이고 component 디렉토리에서 본격적으로 사용되는 뷰를 생성한다.

## Component

```kotlin
/**
 * The main background for the app.
 * Uses[LocalBackgroundTheme] to set the color and tonal elevation of a[Surface].
 *
 *@parammodifierModifier to be applied to the background.
 *@paramcontentThe background content.
 */
@Composable
fun NiaBackground(
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit,
) {
    val color =LocalBackgroundTheme.current.color
    val tonalElevation =LocalBackgroundTheme.current.tonalElevation
    Surface(
        color = if (color == Color.Unspecified) Color.Transparent else color,
        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dpelse tonalElevation,
        modifier = modifier.fillMaxSize(),
    ){
CompositionLocalProvider(LocalAbsoluteTonalElevationprovides 0.dp){
content()
}
    }
}

/**
 * A gradient background for select screens. Uses[LocalBackgroundTheme] to set the gradient colors
 * of a[Box] within a[Surface].
 *
 *@parammodifierModifier to be applied to the background.
 *@paramgradientColorsThe gradient colors to be rendered.
 *@paramcontentThe background content.
 */
@Composable
fun NiaGradientBackground(
    modifier: Modifier = Modifier,
    gradientColors: GradientColors =LocalGradientColors.current,
    content: @Composable () -> Unit,
) {
    val currentTopColor by rememberUpdatedState(gradientColors.top)
    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)
    Surface(
        color = if (gradientColors.container == Color.Unspecified) {
            Color.Transparent
        } else {
            gradientColors.container
        },
        modifier = modifier.fillMaxSize(),
    ){
Box(
            Modifier
                .fillMaxSize()
                .drawWithCache{
// Compute the start and end coordinates such that the gradients are angled 11.06
                    // degrees off the vertical axis
                    val offset = size.height *tan(
                        Math
                            .toRadians(11.06)
                            .toFloat(),
                    )

                    val start =Offset(size.width / 2 + offset / 2, 0f)
                    val end =Offset(size.width / 2 - offset / 2, size.height)

                    // Create the top gradient that fades out after the halfway point vertically
                    val topGradient = Brush.linearGradient(
                        0ftoif (currentTopColor == Color.Unspecified) {
                            Color.Transparent
                        } else {
                            currentTopColor
                        },
                        0.724ftoColor.Transparent,
                        start = start,
                        end = end,
                    )
                    // Create the bottom gradient that fades in before the halfway point vertically
                    val bottomGradient = Brush.linearGradient(
                        0.2552ftoColor.Transparent,
                        1ftoif (currentBottomColor == Color.Unspecified) {
                            Color.Transparent
                        } else {
                            currentBottomColor
                        },
                        start = start,
                        end = end,
                    )

                    onDrawBehind{
// There is overlap here, so order is important
                        drawRect(topGradient)
                        drawRect(bottomGradient)
}
                },
        ){
content()
}
    }
}

/**
 * Multipreview annotation that represents light and dark themes. Add this annotation to a
 * composable to render the both themes.
 */
@Preview(uiMode = Configuration.UI_MODE_NIGHT_NO, name = "Light theme")
@Preview(uiMode = Configuration.UI_MODE_NIGHT_YES, name = "Dark theme")
annotation class ThemePreviews

@ThemePreviews
@Composable
fun BackgroundDefault() {
    NiaTheme(disableDynamicTheming = true){
NiaBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun BackgroundDynamic() {
    NiaTheme(disableDynamicTheming = false){
NiaBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun BackgroundAndroid() {
    NiaTheme(androidTheme = true){
NiaBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun GradientBackgroundDefault() {
    NiaTheme(disableDynamicTheming = true){
NiaGradientBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun GradientBackgroundDynamic() {
    NiaTheme(disableDynamicTheming = false){
NiaGradientBackground(Modifier.size(100.dp), content ={})
}
}

@ThemePreviews
@Composable
fun GradientBackgroundAndroid() {
    NiaTheme(androidTheme = true){
NiaGradientBackground(Modifier.size(100.dp), content ={})
}
}

```

`NiaBackground` 을 보면 주석에 적힌대로 앱 배경의 메인이다.

위에서 본 *`LocalBackgroundTheme`* 으로 color와 tonal을 설정하게 된다.

이제 각각 color와 tonal을 *`LocalBackgroundTheme`*로 최근값을 가져와서 default로 넣었던 Unspecified를 체크해서 설정한다.

그리고 만약 변경이 되면 `CompositionLocalProvider` 로 재설정을 해준다.

`NiaGradientBackground` 은 위에서 그라데이션이 추가가 된 배경이고 `gradientColors` 을 *`LocalGradientColors`*의 최신값을 받아서 온다.

여기서도 Unspecified를 체크하고 `Box` 컴포저블 함수로 본격적으로 그린다.

각 그라데이션 설정은 이미 코딩된 값으로 그라데이션이 들어간 배경을 *`drawWithCache`* 로 그린다.

그리고 아래부분은 preview부분으로 확인용도인거같다.

```kotlin
/**
 * Now in Android filled button with generic content slot. Wraps Material 3[Button].
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramcontentPaddingThe spacing values to apply internally between the container and the
 * content.
 *@paramcontentThe button content.
 */
@Composable
fun NiaButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: @Composable RowScope.() -> Unit,
) {
    Button(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        colors = ButtonDefaults.buttonColors(
            containerColor = MaterialTheme.colorScheme.onBackground,
        ),
        contentPadding = contentPadding,
        content = content,
    )
}

/**
 * Now in Android filled button with text and icon content slots.
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramtextThe button text label content.
 *@paramleadingIconThe button leading icon content. Pass `null` here for no leading icon.
 */
@Composable
fun NiaButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    text: @Composable () -> Unit,
    leadingIcon: @Composable (() -> Unit)? = null,
) {
    NiaButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        contentPadding = if (leadingIcon != null) {
            ButtonDefaults.ButtonWithIconContentPadding
        } else {
            ButtonDefaults.ContentPadding
        },
    ){
NiaButtonContent(
            text = text,
            leadingIcon = leadingIcon,
        )
}
}

/**
 * Now in Android outlined button with generic content slot. Wraps Material 3[OutlinedButton].
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramcontentPaddingThe spacing values to apply internally between the container and the
 * content.
 *@paramcontentThe button content.
 */
@Composable
fun NiaOutlinedButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: @Composable RowScope.() -> Unit,
) {
    OutlinedButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        colors = ButtonDefaults.outlinedButtonColors(
            contentColor = MaterialTheme.colorScheme.onBackground,
        ),
        border =BorderStroke(
            width = NiaButtonDefaults.OutlinedButtonBorderWidth,
            color = if (enabled) {
                MaterialTheme.colorScheme.outline
            } else {
                MaterialTheme.colorScheme.onSurface.copy(
                    alpha = NiaButtonDefaults.DisabledOutlinedButtonBorderAlpha,
                )
            },
        ),
        contentPadding = contentPadding,
        content = content,
    )
}

/**
 * Now in Android outlined button with text and icon content slots.
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramtextThe button text label content.
 *@paramleadingIconThe button leading icon content. Pass `null` here for no leading icon.
 */
@Composable
fun NiaOutlinedButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    text: @Composable () -> Unit,
    leadingIcon: @Composable (() -> Unit)? = null,
) {
    NiaOutlinedButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        contentPadding = if (leadingIcon != null) {
            ButtonDefaults.ButtonWithIconContentPadding
        } else {
            ButtonDefaults.ContentPadding
        },
    ){
NiaButtonContent(
            text = text,
            leadingIcon = leadingIcon,
        )
}
}

/**
 * Now in Android text button with generic content slot. Wraps Material 3[TextButton].
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramcontentThe button content.
 */
@Composable
fun NiaTextButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    content: @Composable RowScope.() -> Unit,
) {
    TextButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        colors = ButtonDefaults.textButtonColors(
            contentColor = MaterialTheme.colorScheme.onBackground,
        ),
        content = content,
    )
}

/**
 * Now in Android text button with text and icon content slots.
 *
 *@paramonClickWill be called when the user clicks the button.
 *@parammodifierModifier to be applied to the button.
 *@paramenabledControls the enabled state of the button. When `false`, this button will not be
 * clickable and will appear disabled to accessibility services.
 *@paramtextThe button text label content.
 *@paramleadingIconThe button leading icon content. Pass `null` here for no leading icon.
 */
@Composable
fun NiaTextButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    text: @Composable () -> Unit,
    leadingIcon: @Composable (() -> Unit)? = null,
) {
    NiaTextButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
    ){
NiaButtonContent(
            text = text,
            leadingIcon = leadingIcon,
        )
}
}

/**
 * Internal Now in Android button content layout for arranging the text label and leading icon.
 *
 *@paramtextThe button text label content.
 *@paramleadingIconThe button leading icon content. Default is `null` for no leading icon.Ï
 */
@Composable
private fun NiaButtonContent(
    text: @Composable () -> Unit,
    leadingIcon: @Composable (() -> Unit)? = null,
) {
    if (leadingIcon != null) {
        Box(Modifier.sizeIn(maxHeight = ButtonDefaults.IconSize)){
leadingIcon()
}
}
    Box(
        Modifier
            .padding(
                start = if (leadingIcon != null) {
                    ButtonDefaults.IconSpacing
                } else {
                    0.dp
},
            ),
    ){
text()
}
}

/**
 * Now in Android button default values.
 */
object NiaButtonDefaults {
    //TODO: File bug
// OutlinedButton border color doesn't respect disabled state by default
    const val DisabledOutlinedButtonBorderAlpha = 0.12f

    //TODO: File bug
// OutlinedButton default border width isn't exposed via ButtonDefaults
    val OutlinedButtonBorderWidth = 1.dp
}

```

버튼 부분이다.

역시 버튼에 대한 다양한 뷰가 있기 때문에 제법 양이 있다.

일단 기본 `NiaButton` 부터 보면 특별한건 없고 text를 받는게 아니라 content를 받아서 row로 넣어주는거같다. 

아마 다양한 뷰를 보여주기 위해 text를 직접 넣지 않는거같다.

그리고 다음은 text와 아이콘 둘다 들어가는 버튼이고 아이콘의 경우 null이 기본값으로 안넣어도 되는거같다.

그런데 코드를 보면 Button 컴포저블 함수를 쓰지않고 아래 선언된 `NiaButton`과 `NiaButtonContent`를 사용한다. 

두 함수에 대한건 아래에서 보자.

다음은`NiaOutlinedButton`으로 겉에 line이 있는 버튼이다.

그래서 material의 `OutlinedButton` 함수를 사용해서 그린다.

그리고 그 아래 같은 이름으로 위처럼 아이콘과 함께 그릴수있는 `NiaOutlinedButton` 이 있다.

역시 동일하게 내부 함수로 재구성한다.

`NiaTextButton` 버튼이 다음 선언되어 있는데 위에와 거의 동일한 방식으로 content를 받는 함수, 그리고 text와 icon을 받는 내부함수로 재구성된 함수 이렇게 2개가 존재한다.

그리고 `NiaButtonContent` 가 마지막에 있고 아이콘과 text를 그리는 기본 컴포저블 함수를 선언해둔 곳이다.

```kotlin
/**
 * Now in Android filter chip with included leading checked icon as well as text content slot.
 *
 *@paramselectedWhether the chip is currently checked.
 *@paramonSelectedChangeCalled when the user clicks the chip and toggles checked.
 *@parammodifierModifier to be applied to the chip.
 *@paramenabledControls the enabled state of the chip. When `false`, this chip will not be
 * clickable and will appear disabled to accessibility services.
 *@paramlabelThe text label content.
 */
@Composable
@OptIn(ExperimentalMaterial3Api::class)
fun NiaFilterChip(
    selected: Boolean,
    onSelectedChange: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    label: @Composable () -> Unit,
) {
    FilterChip(
        selected = selected,
        onClick ={onSelectedChange(!selected)},
        label ={
ProvideTextStyle(value = MaterialTheme.typography.labelSmall){
label()
}
        },
        modifier = modifier,
        enabled = enabled,
        leadingIcon = if (selected) {
{
Icon(
                    imageVector = NiaIcons.Check,
                    contentDescription = null,
                )
}
} else {
            null
        },
        shape =CircleShape,
        border = FilterChipDefaults.filterChipBorder(
            borderColor = MaterialTheme.colorScheme.onBackground,
            selectedBorderColor = MaterialTheme.colorScheme.onBackground,
            disabledBorderColor = MaterialTheme.colorScheme.onBackground.copy(
                alpha = NiaChipDefaults.DisabledChipContentAlpha,
            ),
            disabledSelectedBorderColor = MaterialTheme.colorScheme.onBackground.copy(
                alpha = NiaChipDefaults.DisabledChipContentAlpha,
            ),
            selectedBorderWidth = NiaChipDefaults.ChipBorderWidth,
        ),
        colors = FilterChipDefaults.filterChipColors(
            labelColor = MaterialTheme.colorScheme.onBackground,
            iconColor = MaterialTheme.colorScheme.onBackground,
            disabledContainerColor = if (selected) {
                MaterialTheme.colorScheme.onBackground.copy(
                    alpha = NiaChipDefaults.DisabledChipContainerAlpha,
                )
            } else {
                Color.Transparent
            },
            disabledLabelColor = MaterialTheme.colorScheme.onBackground.copy(
                alpha = NiaChipDefaults.DisabledChipContentAlpha,
            ),
            disabledLeadingIconColor = MaterialTheme.colorScheme.onBackground.copy(
                alpha = NiaChipDefaults.DisabledChipContentAlpha,
            ),
            selectedContainerColor = MaterialTheme.colorScheme.primaryContainer,
            selectedLabelColor = MaterialTheme.colorScheme.onBackground,
            selectedLeadingIconColor = MaterialTheme.colorScheme.onBackground,
        ),
    )
}

/**
 * Now in Android chip default values.
 */
object NiaChipDefaults {
    //TODO: File bug
// FilterChip default values aren't exposed via FilterChipDefaults
    const val DisabledChipContainerAlpha = 0.12f
    const val DisabledChipContentAlpha = 0.38f
    val ChipBorderWidth = 1.dp
}

```

chip을 선언한곳으로 특별한건 딱히 없이 nia에 맞는 chip을 컴포즈로 그린다.

해당 부분은 코드를 읽어도 충분할거같다.

```kotlin
/**
 * A wrapper around[AsyncImage] which determines the colorFilter based on the theme
 */
@Composable
fun DynamicAsyncImage(
    imageUrl: String,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    placeholder: Painter? = null,
) {
    val iconTint =LocalTintTheme.current.iconTint
    AsyncImage(
        placeholder = placeholder,
        model = imageUrl,
        contentDescription = contentDescription,
        colorFilter = if (iconTint != null) ColorFilter.tint(iconTint) else null,
        modifier = modifier,
    )
}

```

해당 부분은 imageview인데 AsyncImage는 coil 라이브러리의 함수다.

비동기를 지원하는 이미지뷰로 기본 이미지뷰를 이걸로 대체해서 사용하는거같다.

```kotlin
/**
 * Now in Android toggle button with icon and checked icon content slots. Wraps Material 3
 *[IconButton].
 *
 *@paramcheckedWhether the toggle button is currently checked.
 *@paramonCheckedChangeCalled when the user clicks the toggle button and toggles checked.
 *@parammodifierModifier to be applied to the toggle button.
 *@paramenabledControls the enabled state of the toggle button. When `false`, this toggle button
 * will not be clickable and will appear disabled to accessibility services.
 *@paramiconThe icon content to show when unchecked.
 *@paramcheckedIconThe icon content to show when checked.
 */
@Composable
fun NiaIconToggleButton(
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    icon: @Composable () -> Unit,
    checkedIcon: @Composable () -> Unit = icon,
) {
    //TODO: File bug
// Can't use regular IconToggleButton as it doesn't include a shape (appears square)
    FilledIconToggleButton(
        checked = checked,
        onCheckedChange = onCheckedChange,
        modifier = modifier,
        enabled = enabled,
        colors = IconButtonDefaults.iconToggleButtonColors(
            checkedContainerColor = MaterialTheme.colorScheme.primaryContainer,
            checkedContentColor = MaterialTheme.colorScheme.onPrimaryContainer,
            disabledContainerColor = if (checked) {
                MaterialTheme.colorScheme.onBackground.copy(
                    alpha = NiaIconButtonDefaults.DisabledIconButtonContainerAlpha,
                )
            } else {
                Color.Transparent
            },
        ),
    ){
if (checked) checkedIcon() else icon()
}
}

/**
 * Now in Android icon button default values.
 */
object NiaIconButtonDefaults {
    //TODO: File bug
// IconToggleButton disabled container alpha not exposed by IconButtonDefaults
    const val DisabledIconButtonContainerAlpha = 0.12f
}

```

iconToggleButton을 nia에 맞게 설정하는 부분이다.

FilledIconToggleButton을 사용하는 이유는 shape를 포함하지 않아서라고 한다.

```kotlin
@Composable
fun NiaLoadingWheel(
    contentDesc: String,
    modifier: Modifier = Modifier,
) {
    val infiniteTransition = rememberInfiniteTransition()

    // Specifies the float animation for slowly drawing out the lines on entering
    val startValue = if (LocalInspectionMode.current) 0F else 1F
    val floatAnimValues = (0untilNUM_OF_LINES).map{remember{Animatable(startValue)} }
LaunchedEffect(floatAnimValues){
(0untilNUM_OF_LINES).map{index->
launch{
floatAnimValues[index].animateTo(
                    targetValue = 0F,
                    animationSpec =tween(
                        durationMillis = 100,
                        easing =FastOutSlowInEasing,
                        delayMillis = 40 * index,
                    ),
                )
}
        }
    }

// Specifies the rotation animation of the entire Canvas composable
    val rotationAnim by infiniteTransition.animateFloat(
        initialValue = 0F,
        targetValue = 360F,
        animationSpec =infiniteRepeatable(
            animation =tween(durationMillis =ROTATION_TIME, easing =LinearEasing),
        ),
    )

    // Specifies the color animation for the base-to-progress line color change
    val baseLineColor = MaterialTheme.colorScheme.onBackground
    val progressLineColor = MaterialTheme.colorScheme.inversePrimary
    val colorAnimValues = (0untilNUM_OF_LINES).map{index->
infiniteTransition.animateColor(
            initialValue = baseLineColor,
            targetValue = baseLineColor,
            animationSpec =infiniteRepeatable(
                animation =keyframes{
durationMillis =ROTATION_TIME/ 2
                    progressLineColoratROTATION_TIME/NUM_OF_LINES/ 2withLinearEasing
baseLineColoratROTATION_TIME/NUM_OF_LINESwithLinearEasing
},
                repeatMode = RepeatMode.Restart,
                initialStartOffset = StartOffset(ROTATION_TIME/NUM_OF_LINES/ 2 * index),
            ),
        )
}

// Draws out the LoadingWheel Canvas composable and sets the animations
    Canvas(
        modifier = modifier
            .size(48.dp)
            .padding(8.dp)
            .graphicsLayer{rotationZ = rotationAnim}
.semantics{contentDescription= contentDesc}
.testTag("loadingWheel"),
    ){
repeat(NUM_OF_LINES){index->
rotate(degrees = index * 30f){
drawLine(
                    color = colorAnimValues[index].value,
                    // Animates the initially drawn 1 pixel alpha from 0 to 1
                    alpha = if (floatAnimValues[index].value < 1f) 1f else 0f,
                    strokeWidth = 4F,
                    cap = StrokeCap.Round,
                    start =Offset(size.width / 2, size.height / 4),
                    end =Offset(size.width / 2, floatAnimValues[index].value * size.height / 4),
                )
}
        }
    }
}

@Composable
fun NiaOverlayLoadingWheel(
    contentDesc: String,
    modifier: Modifier = Modifier,
) {
    Surface(
        shape =RoundedCornerShape(60.dp),
        shadowElevation = 8.dp,
        color = MaterialTheme.colorScheme.surface.copy(alpha = 0.83f),
        modifier = modifier
            .size(60.dp),
    ){
NiaLoadingWheel(
            contentDesc = contentDesc,
        )
}
}

@ThemePreviews
@Composable
fun NiaLoadingWheelPreview() {
    NiaTheme{
Surface{
NiaLoadingWheel(contentDesc = "LoadingWheel")
}
    }
}

@ThemePreviews
@Composable
fun NiaOverlayLoadingWheelPreview() {
    NiaTheme{
Surface{
NiaOverlayLoadingWheel(contentDesc = "LoadingWheel")
}
    }
}

private const valROTATION_TIME= 12000
private const valNUM_OF_LINES= 12
```

로딩휠을 설정하는 부분이다.

로딩휠은 기본을 불러서 수정하는게 아니라 canvas로 새로 그린다.

`rememberInfiniteTransition` 를 사용해서 켜진 동안은 무한으로 반복되게 하고 기본뷰는 참 쉬운데 애니메이션은 아직 어렵다.

`floatAnimValues`은 각 선의 초기 모양을 제어하기 위해 애니메이트 가능한 float 목록을 정의하고 선은 각각 약간의 지연을 두고 하나씩 그려진다.

`LaunchedEffect` 로 각 줄에 대한 코루틴을 실행해서 1부터0까지 지연을 줘 애니메이션화 한다.

`rotationAnim`은 0도에서 360도로 회전하게 한다.

`colorAnimValues`은 기본 색상과 진행률 색상 사이에 전환될 컬러 값이다.

그리고 이 애니메이션을 각 theme에 맞게 색상을 설정한다.

사실 이 뒤로 Navigation, Tabs, Tag등 있지만 기본뷰에서 nia에 맞게 그리고 색상을 theme에 맞게 변경해주는게 전부인거같다.

## 느낀점
컴포즈 기본은 그래도 한눈에 보이는데 아직 애니메이션 부분이 부족한거같다.

## 내일 할 일
nia의 ui부분을 볼거같다.