# 20230320
## ì˜¤ëŠ˜ ê³µë¶€í•œ ë‚´ìš©
## - ğŸ“‘ : Now In Android Deep Dive
# Day3 (2023.03.26)

:core:dataë¥¼ ì•Œì•„ë³´ë ¤ê³  í–ˆì§€ë§Œ databaseì™€ ë¹„ìŠ·í•œ networkë¥¼ ë¨¼ì € ì•Œì•„ë³´ê³  dataë¥¼ ë³´ëŠ”ê²Œ ì¢‹ì„ê±°ê°™ë‹¤.

## Model

ìš°ì„  model ë¶€í„° ì•Œì•„ë³¸ë‹¤.

```kotlin
/**
 * Network representation of[Topic]
*/
@Serializable
data class NetworkTopic(
    val id: String,
    val name: String = "",
    val shortDescription: String = "",
    val longDescription: String = "",
    val url: String = "",
    val imageUrl: String = "",
    val followed: Boolean = false,
)

```

ë„¤íŠ¸ì›Œí¬ì—ì„œ ë°›ëŠ” Topicì— ëŒ€í•œ data classë¡œ ì£¼ì„ì—ë„ ì¨ìˆëŠ”ê²ƒì²˜ëŸ¼ ê¸°ì¡´ì— databaseì—ì„œ ë´¤ë˜ topoic data classì™€ ê±°ì˜ ë˜‘ê°™ë‹¤ ë‹¤ë¥¸ ì ì€ ë§ˆì§€ë§‰ followed í•„ë“œê°€ ì¶”ê°€ ë˜ì—ˆë‹¤ëŠ”ê²ƒì´ë‹¤.

ì•„ë§ˆ followed ì—¬ë¶€ëŠ” ì„œë²„ì—ì„œ ë°›ëŠ”ê±°ë¡œ í™•ì¸í•˜ëŠ”ê±° ê°™ë‹¤.

```kotlin
/**
 * Network representation of[NewsResource] when fetched from /newsresources
 */
@Serializable
data class NetworkNewsResource(
    val id: String,
    val title: String,
    val content: String,
    val url: String,
    val headerImageUrl: String,
    @Serializable(InstantSerializer::class)
    val publishDate: Instant,
    @Serializable(NewsResourceTypeSerializer::class)
    val type: NewsResourceType,
    val topics: List<String> =listOf(),
)

/**
 * Network representation of[NewsResource] when fetched from /newsresources/{id}
 */
@Serializable
data class NetworkNewsResourceExpanded(
    val id: String,
    val title: String,
    val content: String,
    val url: String,
    val headerImageUrl: String,
    @Serializable(InstantSerializer::class)
    val publishDate: Instant,
    @Serializable(NewsResourceTypeSerializer::class)
    val type: NewsResourceType,
    val topics: List<NetworkTopic> =listOf(),
)

```

ìœ„ data class ë˜í•œ NewsResource data classë¥¼ ì„œë²„ì—ì„œ ë°›ëŠ” ëª¨ë¸ë¡œ ë§Œë“ ê²ƒì´ë‹¤. ì—¬ê¸°ì„œ ì¡°ê¸ˆ ë‹¤ë¥¸ì ì€ `@Serializable(InstantSerializer::class)`ì™€`@Serializable(NewsResourceTypeSerializer::class)`ì´ê±°ë‹¤. 

utilë¶€ë¶„ì—ì„œ ìì„¸íˆ ë‹¤ë£¨ê² ì§€ë§Œ ê°„ë‹¨í•˜ê²Œ ë§í•˜ë©´ `KSerializer`ë¥¼ ìƒì†ë°›ëŠ” í´ë˜ìŠ¤ë¡œ `Serializer` ì˜ ì»¤ìŠ¤í…€ì´ë‹¤.

ê·¸ë¦¬ê³  ë¹„ìŠ·í•œ ì´ë¦„ì˜ í´ë˜ìŠ¤ë¡œ Expandedëœ data classë„ ë”°ë¡œ ë°›ëŠ”ë‹¤. 

ê·¼ë° ì–´ì§¸ ë°›ëŠ” í•„ë“œëŠ” ì „ë¶€ ê°™ë‹¤? ì´ê±´ ì¢€ ì•Œì•„ë´ì•¼ í• ë“¯.

ì£¼ì„ì— ì˜í•˜ë©´ {id}ë¥¼ requestí• ë•Œ ë³´ë‚´ì„œ í•´ë‹¹ idì˜ ë°ì´í„°ë¥¼ ë°›ëŠ”ê±°ê°™ë‹¤.

```kotlin
/**
 * Network representation of a change list for a model.
 *
 * Change lists are a representation of a server-side map like data structure of model ids to
 * metadata about that model. In a single change list, a given model id can only show up once.
 */
@Serializable
data class NetworkChangeList(
/**
     * The id of the model that was changed
     */
val id: String,
/**
     * Unique consecutive, monotonically increasing version number in the collection describing
     * the relative point of change between models in the collection
     */
val changeListVersion: Int,
/**
     * Summarizes the update to the model; whether it was deleted or updated.
     * Updates include creations.
     */
val isDelete: Boolean,
)

```

ì„œë²„ì—ì„œ ë³€ê²½ëœ ë¶€ë¶„ì—ëŒ€í•œ ë°ì´í„°ë¥¼ ë°›ëŠ” ëª¨ë¸ì´ë‹¤. ì£¼ì„ì´ë‘ ì†ŒìŠ¤ë¥¼ ë³´ë©´ì„œ ì´í•´ë¥¼ ì¢€ í•´ë³´ìë©´ ë¡œì»¬ë¡œ ì´ì „ì— ë°›ì•˜ë˜ ë°ì´í„°ì™€ ì„œë²„ì—ì„œ ë³€ê²½ ë° ì‚­ì œëœ ë°ì´í„°ì— ì‹±í¬ë¥¼ ë§ì¶”ê¸° ìœ„í•œ ëª¨ë¸ë¡œ ë³´ì¸ë‹¤.

ë¡œì»¬ê³¼ ì„œë²„ì˜ ë°ì´í„° ì‚¬ì´ ì‹œê°„ì— ë”°ë¼ ë³€ê²½ ë° ì‚­ì œê°€ ì´ë£¨ì–´ì§ˆìˆ˜ìˆìœ¼ë‹ˆ idë¥¼ ë°›ê³  changeListVersionìœ¼ë¡œ ì ìš©ëœ ë²„ì „ì„ ì²´í¬í•˜ê³  isDeleteë¡œ ì‚­ì œ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ëŠ”ê±°ë¡œ ë³´ì¸ë‹¤.

ë¡œì»¬ì˜ ë¹ ë¥¸ ì†ë„ì™€ ì•ˆì •ì„± ê·¸ë¦¬ê³  ì„œë²„ì˜ ë°ì´í„°ë¥¼ ëª¨ë‘ í™œìš©í•˜ê¸° ìœ„í•œ ë¶€ë¶„ì¸ê±°ê°™ë‹¤.

## Model Util

```kotlin
object InstantSerializer : KSerializer<Instant> {
    override fun deserialize(decoder: Decoder): Instant =
        decoder.decodeString().toInstant()

    override val descriptor: SerialDescriptor =PrimitiveSerialDescriptor(
        serialName = "Instant",
        kind = STRING,
    )

    override fun serialize(encoder: Encoder, value: Instant) =
        encoder.encodeString(value.toString())
}

```

ì•„ê¹Œ ìœ„ì—ì„œ ë³´ì•˜ë˜ InstantSerializerì˜ ì†ŒìŠ¤ì½”ë“œë‹¤. 

KSerializerë¡œ ìƒì† ë°›ê³  deserialize, descriptor, serializeë¥¼ ovrride í•¨ìˆ˜ë¡œ ì‚¬ìš©í•œë‹¤.

ìš°ì„  í•´ë‹¹ ë¶€ë¶„ì„ ì´í•´í•˜ê¸° ìœ„í•´ Serializalbeì— ëŒ€í•´ ì´í•´í•´ì•¼í•œë‹¤.

SerializalbeëŠ” ê°„ë‹¨í•˜ê²Œ ë§í•˜ë©´ Objectë¥¼ Json Formatìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ì–´ë…¸í…Œì´ì…˜ì´ë‹¤. ì´ê±¸ ì§ë ¬í™”ë¼í•œë‹¤. ê·¸ëŸ¼ ì—­ì§ë ¬í™”ëŠ” ë‹¤ì‹œ ë°˜ëŒ€ë¡œ Jsonì—ì„œ Objectë¡œ ë³€ê²½í•˜ëŠ”ê²ƒì´ë‹¤. ê·¸ë˜ì„œ ì„œë²„ í†µì‹ ì‹œ ë§ì´ ì‚¬ìš©í•˜ê²Œ ëœë‹¤.

ê·¸ëŸ¼ í•´ë‹¹ í´ë˜ìŠ¤ì—ì„œ í•˜ê³  ì‹¶ì€ê±´ ì§ë ¬í™”ì™€ ì—­ì§ë ¬í™”ë¥¼ í•˜ëŠ”ë¶€ë¶„ì„ ì»¤ìŠ¤í…€ í•˜ê¸° ìœ„í•œ í´ë˜ìŠ¤ì¼ê²ƒì´ë‹¤.

deserializeì€ ì—­ì§ë ¬í™” ë¶€ë¶„ì´ë‹¤. í•´ë‹¹ í´ë˜ìŠ¤ì—ì„œëŠ” ê°„ë‹¨í•˜ê²Œ decodeëœ stringì„ toInstantë¡œ ìºìŠ¤íŒ…í•œë‹¤. ê·¸ëŸ¼ ì§ë ¬í™”ëŠ” ë°˜ëŒ€ë¡œ Instantë¥¼ Stringìœ¼ë¡œ ìºìŠ¤íŒ…í•˜ê³  encodeí•œë‹¤. 

ë§ˆì§€ë§‰ìœ¼ë¡œ descriptorì€ serialNameì™€ ì¢…ë¥˜ë¥¼ ê²°ì •í•˜ëŠ”ë° ë³´ëŠ”ê²ƒê³¼ ê°™ì´ ê°„ë‹¨í•˜ê²Œ Instantë¡œ ì´ë¦„ì„ ì •í•˜ê³  Stringìœ¼ë¡œ ì •í•œë‹¤.

```kotlin
object NewsResourceTypeSerializer : KSerializer<NewsResourceType> {
    override fun deserialize(decoder: Decoder): NewsResourceType =
        decoder.decodeString().asNewsResourceType()

    override val descriptor: SerialDescriptor =PrimitiveSerialDescriptor(
        serialName = "type",
        kind = STRING,
    )

    override fun serialize(encoder: Encoder, value: NewsResourceType) =
        encoder.encodeString(value.serializedName)
}

```

ì´ì œ ìœ„ì— ì•Œì•„ë³¸ëŒ€ë¡œ ì½”ë“œë¥¼ ë³´ë©´ NewsResourceTypeê°ì²´ë¥¼ ì§ë ¬í™”, ì—­ì§ë ¬í™”ë¥¼ í•˜ëŠ” ë¶€ë¶„ì„ ì»¤ìŠ¤í…€í•˜ëŠ” ë¶€ë¶„ì¸ê±¸ í•œëˆˆì— ì•Œìˆ˜ìˆë‹¤.

ê·¼ë° ì½”ë“œëŠ” ì´í•´í–ˆëŠ”ë° ì™œ ì‚¬ìš©í–ˆëŠ”ì§€ì— ëŒ€í•´ ì´í•´ê°€ ì•ˆë˜ì„œ ì¢€ ë” ì°¾ì•„ë´¤ëŠ”ë° Instantë‚˜ NewsResourceType(ì´ê±´ ë‹¹ì—°íˆ ì»¤ìŠ¤í…€ì´ë‹ˆê¹) ê¸°ë³¸ ìƒì„±ìê°€ ì—†ê³  ê¸°ë³¸ ì§ë ¬í™” í˜•ì‹ê³¼ ì¼ì¹˜í•˜ì§€ ì•Šì•„ì„œ ì»¤ìŠ¤í…€ìœ¼ë¡œ í•´ì¤€ë‹¤ê³  í•œë‹¤

ì´ì œ ë””ë ‰í† ë¦¬ ë°–ì— ìˆëŠ” DataSourceë¥¼ ë³´ì

```kotlin
/**
 * Interface representing network calls to the NIA backend
 */
interface NiaNetworkDataSource {
    suspend fun getTopics(ids: List<String>? = null): List<NetworkTopic>

    suspend fun getNewsResources(ids: List<String>? = null): List<NetworkNewsResource>

    suspend fun getTopicChangeList(after: Int? = null): List<NetworkChangeList>

    suspend fun getNewsResourceChangeList(after: Int? = null): List<NetworkChangeList>
}

```

í•´ë‹¹ ë¶€ë¶„ì€ ì£¼ì„ì— ì¨ìˆëŠ”ëŒ€ë¡œ nia ì„œë²„ì™€ í†µì‹ í•˜ê¸° ìœ„í•´ interfaceë¡œ ë§Œë“  ë¶€ë¶„ì´ë‹¤. í•´ë‹¹ë¶€ë¶„ì„ ë‹¤ë¥¸ê³³ì—ì„œ ìƒì†ë°›ì•„ ì‚¬ìš©í•˜ë ¤ê³  interfaceë¡œ ë§Œë“¤ì—ˆëŠ”ë° ì•„ë§ˆ FakeDataSourceë„ ìˆê¸° ë•Œë¬¸ì— ì¼ë¶€ëŸ¬ interfaceë¡œ ë”°ë¡œ ë¹¼ë‘”ê±°ê°™ë‹¤.

ê·¸ë¦¬ê³  Network ë¶€ë¶„ì„ ë³´ì

```kotlin

/**
 * Retrofit API declaration for NIA Network API
 */
private interface RetrofitNiaNetworkApi {
    @GET(value = "topics")
    suspend fun getTopics(
        @Query("id") ids: List<String>?,
    ): NetworkResponse<List<NetworkTopic>>

    @GET(value = "newsresources")
    suspend fun getNewsResources(
        @Query("id") ids: List<String>?,
    ): NetworkResponse<List<NetworkNewsResource>>

    @GET(value = "changelists/topics")
    suspend fun getTopicChangeList(
        @Query("after") after: Int?,
    ): List<NetworkChangeList>

    @GET(value = "changelists/newsresources")
    suspend fun getNewsResourcesChangeList(
        @Query("after") after: Int?,
    ): List<NetworkChangeList>
}

private const valNiaBaseUrl= BuildConfig.BACKEND_URL

/**
 * Wrapper for data provided from the[NiaBaseUrl]
*/
@Serializable
private data class NetworkResponse<T>(
    val data: T,
)

/**
 *[Retrofit] backed[NiaNetworkDataSource]
*/
@Singleton
class RetrofitNiaNetwork @Inject constructor(
    networkJson: Json,
    okhttpCallFactory: Call.Factory,
) : NiaNetworkDataSource {

    private val networkApi = Retrofit.Builder()
        .baseUrl(NiaBaseUrl)
        .callFactory(okhttpCallFactory)
        .addConverterFactory(
            @OptIn(ExperimentalSerializationApi::class)
            networkJson.asConverterFactory("application/json".toMediaType()),
        )
        .build()
        .create(RetrofitNiaNetworkApi::class.java)

    override suspend fun getTopics(ids: List<String>?): List<NetworkTopic> =
        networkApi.getTopics(ids = ids).data

    override suspend fun getNewsResources(ids: List<String>?): List<NetworkNewsResource> =
        networkApi.getNewsResources(ids = ids).data

    override suspend fun getTopicChangeList(after: Int?): List<NetworkChangeList> =
        networkApi.getTopicChangeList(after = after)

    override suspend fun getNewsResourceChangeList(after: Int?): List<NetworkChangeList> =
        networkApi.getNewsResourcesChangeList(after = after)
}

```

ì´ ì½”ë“œëŠ” ì•„ë˜ì—ì„œë¶€í„° ë³´ê² ë‹¤.

`RetrofitNiaNetwork` ëŠ” retrofitì´ë‚˜ ë‹¤ë¥¸ networkê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ë©´ ë§ì´ ë´¤ì„ ì½”ë“œ í˜•ì‹ì¼ê²ƒì´ë‹¤. ì„œë²„ì™€ ë„¤íŠ¸ì›Œí¬ í†µì‹ ì„ ìœ„í•œ ë¶€ë¶„ì´ê³  `NiaNetworkDataSource` ë¥¼ ìƒì†ë°›ëŠ”ë‹¤. 

ê·¸ë ‡ê¸° ë•Œë¬¸ì— `getTopics`, `getNewsResources`, `getTopicChangeList`, `getNewsResourceChangeList` ë¥¼ overrideí•˜ê²Œ ë˜ê³  `networkApi` ê°ì²´ë¡œ í†µì‹ ì„ í•œë‹¤.

`networkApi` ëŠ” `RetrofitNiaNetworkApi`ë¥¼ ë°˜í™˜í•˜ê³  ì£¼ì†Œ, í˜•ì‹ë“±ì„ ì„œë²„ì™€ í”„ë¡œì íŠ¸ì— ë§ê²Œ ë„£ì–´ì¤€ë‹¤.

ì§€ê¸ˆ í´ë˜ìŠ¤ì—ì„œëŠ” Call.Factoryì™€ Jsonì„ ì£¼ì…ë°›ëŠ”ë° í•´ë‹¹ ë¶€ë¶„ì€ dië¶€ë¶„ì—ì„œ ìì„¸íˆ ë³´ì.

`NetworkResponse<T>` ë¶€ë¶„ì„ ë³´ë©´ ë˜í•‘í•´ì¤€ë‹¤ëŠ”ê±¸ ì•Œìˆ˜ìˆëŠ”ë° ì‚¬ìš© ì´ìœ ëŠ” Responseì— ëŒ€í•œ ë˜í¼ë¥¼ í•˜ëŠ” ì—­í• ì¸ë° ì§€ê¸ˆê¹Œì§€ ë´ì„œëŠ” ì˜ëª¨ë¥´ê² ë‹¤. ê²€ìƒ‰ì„ í•´ë´ì„œ ì•Œì•„ë³¸ ê²°ê³¼ë¡œëŠ” ë˜í¼ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë©´ ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ì—ì„œ API ì‘ë‹µì´ êµ¬ì¡°í™”ë˜ëŠ” ë°©ì‹ì„ í‘œì¤€í™”í•  ìˆ˜ ìˆë‹¤ê³  í•˜ëŠ”ë° ì•„ì§ì€ ì˜ ì´í•´ê°€ ì•ˆëœë‹¤.

ê·¸ë¦¬ê³  `RetrofitNiaNetworkApi` ë¶€ë¶„ì„ ë³´ë©´ ì‹¤ì œ ì„œë²„ì— ë³´ë‚´ëŠ” request ì£¼ì†Œì™€ ë°©ì‹ì´ ì¨ì ¸ìˆë‹¤. ì´ë¶€ë¶„ì€ retrofitì„ í•´ë´¤ìœ¼ë©´ ì§€ê²¹ê²Œ ë´¤ì„í…Œë‹ˆ ë„˜ì–´ê°„ë‹¤.

## Fake

fakeëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ datasourceì´ë‹¤. 

ë•Œë¬¸ì— ê³ ì •ëœ í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¥¼ ì œê³µí•´ì£¼ê³  ê·¸ ë°ì´í„°ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ í•œë‹¤.

```kotlin
/**
 *[NiaNetworkDataSource] implementation that provides static news resources to aid development
 */
class FakeNiaNetworkDataSource @Inject constructor(
    @Dispatcher(IO) private val ioDispatcher: CoroutineDispatcher,
    private val networkJson: Json,
    private val assets: FakeAssetManager = JvmUnitTestFakeAssetManager,
) : NiaNetworkDataSource {

    companion object {
        private const val AUTHORS_ASSET = "authors.json"
        private const val NEWS_ASSET = "news.json"
        private const val TOPICS_ASSET = "topics.json"
    }

    @OptIn(ExperimentalSerializationApi::class)
    override suspend fun getTopics(ids: List<String>?): List<NetworkTopic> =
        withContext(ioDispatcher){
assets.open(TOPICS_ASSET).use(networkJson::decodeFromStream)
}

@OptIn(ExperimentalSerializationApi::class)
    override suspend fun getNewsResources(ids: List<String>?): List<NetworkNewsResource> =
        withContext(ioDispatcher){
assets.open(NEWS_ASSET).use(networkJson::decodeFromStream)
}

override suspend fun getTopicChangeList(after: Int?): List<NetworkChangeList> =
        getTopics().mapToChangeList(NetworkTopic::id)

    override suspend fun getNewsResourceChangeList(after: Int?): List<NetworkChangeList> =
        getNewsResources().mapToChangeList(NetworkNewsResource::id)
}

/**
 * Converts a list of[T] to change list of all the items in it where[idGetter] defines the
 *[NetworkChangeList.id]
*/
private fun <T> List<T>.mapToChangeList(
    idGetter: (T) -> String,
) =mapIndexed{index, item->
NetworkChangeList(
        id = idGetter(item),
        changeListVersion = index,
        isDelete = false,
    )
}

```

`FakeNiaNetworkDataSource` ëŠ” `NiaNetworkDataSource` ì„ ìƒì†í•˜ê¸° ë•Œë¬¸ì— `NiaNetworkDataSource`ì˜ requestë¶€ë¶„ì„ ë˜‘ê°™ì´ ì‚¬ìš©í•˜ê²Œ ëœë‹¤.

`NiaNetworkDataSource` ì™€ì˜ ì°¨ì´ì ì€ Dispatcherì™€ asstetsì„ ìƒì„±ìë¡œ ë°›ëŠ”ë° Dispatcherë¥¼ ì§ì ‘ ì½”ë“œì—ì„œ ì‚¬ìš©í•˜ì§€ì•Šê³  ë°›ëŠ” ì´ìœ ëŠ” í…ŒìŠ¤íŠ¸ ì½”ë“œì—ì„œ ë™ì¼í•œ Dispatcherë¥¼ ë³´ë‚´ê¸° ìœ„í•´ì„œ ì¸ê±°ê°™ì•„ë³´ì¸ë‹¤.

ê·¸ë¦¬ê³  assetsì—ì„œ `FakeAssetManager` ë¥¼ `JvmUnitTestFakeAssetManager` ë¡œ ì£¼ì…í•˜ëŠ”ë°

```kotlin
fun interface FakeAssetManager {
    fun open(fileName: String): InputStream
}

```

`FakeAssetManager`ëŠ” Stringì„ inputStream í˜•íƒœë¡œ ë°›ëŠ” interfaceì´ê³  ì´ê±¸ 

```kotlin
@VisibleForTesting
internal object JvmUnitTestFakeAssetManager : FakeAssetManager {
    private val config =
requireNotNull(javaClass.getResource("com/android/tools/test_config.properties")){
"""
            Missing Android resources properties file.
            Did you forget to enable the feature in the gradle build file?
            android.testOptions.unitTests.isIncludeAndroidResources = true
            """.trimIndent()
}
private val properties = Properties().apply{config.openStream().use(::load)}
private val assets = File(properties["android_merged_assets"].toString())

    override fun open(fileName: String): InputStream = File(assets, fileName).inputStream()
}

```

í•´ë‹¹ í´ë˜ìŠ¤ì—ì„œ JVM ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•  ë•Œ Android /assets íŒŒì¼ì„ ë¡œë“œí•˜ëŠ” í¸í•˜ê²Œ í•˜ê¸° ìœ„í•´ ë§Œë“  ê°ì²´ë‹¤. ìƒëŒ€ ê²½ë¡œë¥¼ ì‚¬ìš©í•˜ëŠ” Class.getResourceë¥¼ ë” ì‰½ê²Œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ë£¨íŠ¸ ê²½ë¡œì— ìœ„ì¹˜í•´ ë‘”ë‹¤.

ì´ë ‡ê²Œ assetsì„ json í˜•íƒœë¡œ ë¡œì»¬ì— ì €ì¥í•´ì„œ í…ŒìŠ¤íŠ¸ë¥¼ í•œë‹¤.

ê·¸ë˜ì„œ ê° suspend fun ë§ˆë‹¤ í•„ìš”í•œ assetsì„ ë„£ì–´ì£¼ê³  decodeë¥¼ í•´ì„œ ê°’ì„ ë°›ë„ë¡ í•œë‹¤.

`mapToChangeList` í•´ë‹¹ í•¨ìˆ˜ëŠ” idì— ë§ëŠ” ê°’ì„ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ê°’ì„ jsonì— ë„£ê³  ì°¾ì•„ì˜¨ jsonì„ ë„£ì–´ì£¼ëŠ” ê¸°ëŠ¥ì„ í•œë‹¤.

## Di

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun providesNetworkJson(): Json =Json{
ignoreUnknownKeys = true
}

@Provides
    @Singleton
    fun providesFakeAssetManager(
        @ApplicationContext context: Context,
    ): FakeAssetManager =FakeAssetManager(context.assets::open)

    @Provides
    @Singleton
    fun okHttpCallFactory(): Call.Factory = OkHttpClient.Builder()
        .addInterceptor(
            HttpLoggingInterceptor()
                .apply{
if (BuildConfig.DEBUG) {
                        setLevel(HttpLoggingInterceptor.Level.BODY)
                    }
},
        )
        .build()

/**
     * Since we're displaying SVGs in the app, Coil needs an ImageLoader which supports this
     * format. During Coil's initialization it will call `applicationContext.newImageLoader()` to
     * obtain an ImageLoader.
     *
     *@see<a href="https://github.com/coil-kt/coil/blob/main/coil-singleton/src/main/java/coil/Coil.kt">Coil</a>
     */
@Provides
    @Singleton
    fun imageLoader(
        okHttpCallFactory: Call.Factory,
        @ApplicationContext application: Context,
    ): ImageLoader = ImageLoader.Builder(application)
        .callFactory(okHttpCallFactory)
        .components{
add(SvgDecoder.Factory())
}
// Assume most content images are versioned urls
        // but some problematic images are fetching each time
        .respectCacheHeaders(false)
        .apply{
if (BuildConfig.DEBUG) {
                logger(DebugLogger())
            }
}
.build()
}

```

ë„¤íŠ¸ì›Œí¬ dië¶€ë¶„ì´ë‹¤. 

ì•„ê¹Œ `RetrofitNiaNetwork` í´ë˜ìŠ¤ì—ì„œ ì£¼ì… ë°›ëŠ”ë¶€ë¶„ë“¤ì´ ì—¬ê¸°ì— ìˆë‹¤.

ë¨¼ì € `providesNetworkJson` ì€ Jsonì„ ë°˜í™˜í•˜ëŠ” í´ë˜ìŠ¤ì¸ë° `ignoreUnknownKeys = true` ë§Œ ë©ê·¸ëŸ¬ë‹ˆ ìˆë‹¤. í•´ë‹¹ ë¶€ë¶„ì„ íƒ€ê³  ë“¤ì–´ê°€ë©´ ì¹œì ˆí•˜ê²Œ ì£¼ì„ì´ ìˆëŠ”ë° ë‚´ìš©ì€ input JSONì—ì„œ ì•Œ ìˆ˜ ì—†ëŠ” í”„ë¡œí¼í‹°ë¥¼ ë°œê²¬í•˜ë©´ SerializationExceptionì„ throwí•˜ëŠ” ëŒ€ì‹  ë¬´ì‹œí• ì§€ ì—¬ë¶€ë¥¼ ì§€ì •í•©ë‹ˆë‹¤. ê¸°ë³¸ê°’ì€ falseì…ë‹ˆë‹¤. ì´ë¼ê³  ì¨ì ¸ìˆë‹¤.(ë¬¼ë¡  ì˜ì–´ë¡œ)

ì´ì œ í•´ë‹¹ê°’ì„ falseë¡œ ë’€ìœ¼ë‹ˆ ì„œë²„ì—ì„œ ì•Œìˆ˜ì—†ëŠ” jsonì„ ì£¼ë”ë¼ë„ exceptionìœ¼ë¡œ ë–¨ì–´ì§€ì§€ì•Šê³  ë¬´ì‹œí•˜ê¸° ë•Œë¬¸ì— ê°œë°œì ì…ì¥ì—ì„œ exceptionë¶€ë‹´ì„ ëœì–´ì£¼ê³  ì•½ì†ëœ ë‚´ìš©ë§Œ ë³´ì—¬ì¤„ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë§ì´ ìœ ìš©í•˜ë‹¤. (ì„œë²„ì™€ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ì´ ì˜ ì•ˆëœë‹¤ë©´ ì¤¬ëŠ”ë° ì™œ ëª»ë°›ì•„? ë¼ëŠ” ìƒí™©ì´ ìƒê¸¸ìˆ˜ë„ ìˆìœ¼ë‹ˆ ì£¼ì˜)

`providesFakeAssetManager` ì€ ìœ„ì˜ fake ë¶€ë¶„ì—ì„œ assetsManagerë¥¼ ì£¼ì…í•´ì¤€ë‹¤.

`okHttpCallFactory` ì€ `HttpLoggingInterceptor` ë¥¼ ì¶”ê°€í•˜ê³  ë””ë²„ê·¸ì¸ ê²½ìš° levelì„ Bodyë¡œ ì„¤ì •í•˜ê²Œ ëœë‹¤. LoggingInterceptorì´ê¸° ë•Œë¬¸ì— ë””ë²„ê·¸ì¼ë•Œë§Œ BODYì— ë¡œê¹…í•˜ë„ë¡ í•œë‹¤.

ë§ˆì§€ë§‰ `imageLoader` ì€ coilì—ì„œ svgíŒŒì¼ì„ ë¡œë“œí•˜ê³  ë””ì½”ë”© í•˜ê¸°ìœ„í•´ ì‚¬ìš©ëœë‹¤.

## ëŠë‚€ì 
Jsonì„ ì´ë ‡ê²Œ ë‹¤ì–‘í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ëŠ”ê±¸ ë°°ìš°ê²Œ ëœê±°ê°™ë‹¤.
ì‚¬ì‹¤ íšŒì‚¬ í”„ë¡œì íŠ¸ì—ì„œëŠ” ê·¸ì € Serializeë§Œ í•´ì„œ í†µì‹ í•˜ëŠ”ê²Œ ëì´ì˜€ëŠ”ë° ìƒê°ë³´ë‹¤ ë” ì„¬ì„¸í•˜ê²Œ í•´ì¤„ìˆ˜ ìˆëŠ” ì‘ì—…ì´ ìˆì–´ì„œ í˜„ì—…ì— ì ìš©í•˜ê³  ì‹¶ì—ˆë‹¤.
ê·¸ë¦¬ê³  ê·¸ëƒ¥ ì½”ë“œë¥¼ ë³¼ë• ì™œ fakeíŒŒì¼ ê¹Œì§€ ë§Œë“¤ì–´ì„œ í…ŒìŠ¤íŠ¸í•˜ë‚˜ í–ˆëŠ”ë° í•˜ë‚˜í•˜ë‚˜ ì‚´í´ë³´ë‹ˆ ì´ì œ ì¢€ ì´í•´ê°€ ë˜ëŠ”ê±° ê°™ë‹¤. (ê·¸ë˜ë„ ì—¬ì „íˆ ê·€ì°®ì•„ ë³´ì´ê¸´í•œë‹¤.ã…‹ã…‹)

## ë‚´ì¼ í•  ì¼
nia coreì˜ dataë¥¼ ì‚´í´ë³¼ê²ƒì´ë‹¤. (ì§„ì§œë¡œx2)